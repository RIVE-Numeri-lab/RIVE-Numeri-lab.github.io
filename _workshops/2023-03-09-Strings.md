---
layout: default
category: Programming
thumbnail: stringr.png
title: "Strings manipulations in R"
author: "Charles Martin"
date: "2023-03-09"
lang: en
output:
  html_document:
    highlight: haddock
    keep_md: yes
    theme: readable
    toc: yes
    self_contained: true
    toc_float: true	
---

# Strings manipulations in R
{:.no_toc}

## Charles Martin
{:.no_toc}

## March 2023
{:.no_toc}

* TOC
{:toc}


#Required Libraries

This workshop will require recent versions of the readr (minimum version 2.1), stringr (minimum version 1.5), tidyr (minimum version 1.3) and dplyr libraries. You can either enable them individually, or enable the tidyverse meta-library:

```r
library(tidyverse)
```

```
â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.2 â”€â”€
âœ” ggplot2 3.4.0      âœ” purrr   1.0.1 
âœ” tibble  3.1.8      âœ” dplyr   1.0.10
âœ” tidyr   1.3.0      âœ” stringr 1.5.0 
âœ” readr   2.1.2      âœ” forcats 0.5.2 
â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
âœ– dplyr::filter() masks stats::filter()
âœ– dplyr::lag()    masks stats::lag()
```

# How is text constructed in R
Before embarking on the manipulation of text *per se*, it is important to understand the nature of text in R and how to construct it.

## How text is encoded in the computer
In R's memory, in CSV files, etc. the text is stored in a series of hexadecimal codes. We can indeed see the corresponding codes with the charToRaw function:


```r
charToRaw("Charles")
```

```
[1] 43 68 61 72 6c 65 73
```

The â€œCâ€ is encoded with 43, the â€œhâ€ with 68, etc.

If we do the mathematics of the thing, we quickly realize that this system can only represent 16*16 = 256 symbols. This worked well at a time when Americans had a hand in computing, but doesn't work at all for encoding text from any language in the world.

In the 1980s-1990s, a series of standards were developed to allow the encoding of characters other than English. Among other things, ISO-8859-1 (Latin1) allowed the encoding of most characters used in Western Europe, Latin2 in Eastern Europe, etc.

Today, there is an international standard, called UTF-8, which makes it possible to encode all imaginable characters, even Emojis!

Most modern software uses this encoding and the use of accents in files is no longer a problem. However, some older applications and some files produced some time ago do not necessarily adhere to this convention.

It is for this reason that sometimes, when loading a CSV file, you will see a series of weird characters in your data:

```r
read_csv("Latin1.csv")
```

```
Rows: 2 Columns: 3
â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Delimiter: ","
chr (1): Col3
dbl (2): Col1, Col2

â„¹ Use `spec()` to retrieve the full column specification for this data.
â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```
# A tibble: 2 Ã— 3
   Col1  Col2 Col3            
  <dbl> <dbl> <chr>           
1     1     2 "All\xf4"       
2     3     4 "\xc0 la place?"
```
With trial and error, we can try to *guess* the correct encoding and specify it at load time:

```r
read_csv("Latin1.csv",locale = locale(encoding = "Windows-1252"))
```

```
Rows: 2 Columns: 3
â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Delimiter: ","
chr (1): Col3
dbl (2): Col1, Col2

â„¹ Use `spec()` to retrieve the full column specification for this data.
â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```
# A tibble: 2 Ã— 3
   Col1  Col2 Col3       
  <dbl> <dbl> <chr>      
1     1     2 AllÃ´       
2     3     4 Ã€ la place?
```

```r
read_csv("Latin1.csv",locale = locale(encoding = "Latin1"))
```

```
Rows: 2 Columns: 3
â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Delimiter: ","
chr (1): Col3
dbl (2): Col1, Col2

â„¹ Use `spec()` to retrieve the full column specification for this data.
â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```
# A tibble: 2 Ã— 3
   Col1  Col2 Col3       
  <dbl> <dbl> <chr>      
1     1     2 AllÃ´       
2     3     4 Ã€ la place?
```

Usually, if you try Latin1, UTF-8, or Windows-1252, you're pretty sure you've got the right one.

Recent versions of the readr library now come with a feature that lets you let the computer do the dirty work for you:

```r
guess_encoding("Latin1.csv")
```

```
# A tibble: 2 Ã— 2
  encoding   confidence
  <chr>           <dbl>
1 ISO-8859-1       0.62
2 ISO-8859-2       0.41
```

## Manual text creation
Now, how can one do to create text in R?

The easiest way is to create a string object, like this:



## CrÃ©ation manuelle de texte
Maintenant, comment peut-on faire pour crÃ©er du texte dans R?

La faÃ§on la plus simple est de crÃ©er un objet chaÃ®ne de caractÃ¨res, comme ceci : 

```r
chaine1 <- "Il faut l'essayer"
chaine2 <- 'Voici un autre "essai"'
```

Note that we can use the single or double quote to start and end our sequence.

In general, it is recommended to use the double quote, unless your character string contains more than one.

You can also include a double quote in a sequence started with a double quote, by using an escape character, i.e. the backslash (\):

```r
chaine3 <- "Je contient un \" et Ã§a fonctionne tout de mÃªme"
```

Therefore, if you want to produce a backslash in a string, you must precede it with another backslash:

```r
backslash <- "\\"
```

Note that if you send one of these strings to the console, you will see the escape character:

```r
chaine3
```

```
[1] "Je contient un \" et Ã§a fonctionne tout de mÃªme"
```

```r
backslash
```

```
[1] "\\"
```
This happens because, by default, R's print function (called implicitly) gives us not what it sees as text, but what we should type to reconstruct it.

If we want to see the true representation of the text (as we will see in graphics, etc.), we can use the str_view function. Compare these two outputs:

```r
print(c(chaine1, chaine2, chaine3))
```

```
[1] "Il faut l'essayer"                              
[2] "Voici un autre \"essai\""                       
[3] "Je contient un \" et Ã§a fonctionne tout de mÃªme"
```

```r
str_view(c(chaine1, chaine2, chaine3))
```

```
[1] â”‚ Il faut l'essayer
[2] â”‚ Voici un autre "essai"
[3] â”‚ Je contient un " et Ã§a fonctionne tout de mÃªme
```

It is also possible to create so-called â€œrawâ€ character strings, for which, when they are created, R does not try to manage escape characters. To do this, we must start our string with `r"(` and end it with `)"`

```r
complexe <- r"(L'apostrophe, le \ et mÃªme les "guillemets" ne posent plus de problÃ¨mes)"
str_view(complexe)
```

```
[1] â”‚ L'apostrophe, le \ et mÃªme les "guillemets" ne posent plus de problÃ¨mes
```
As needed `r"()"` can be replaced with `r"[]"`, `r"{}"`, etc.

## Escape characters

Besides `\"` `\'` and `\\`, there are a series of other special characters when constructing text in R.

Among others : 

* `\n` adds line break
* `\t` adds an indent (tab)
* and `\u` et `\U` allow us to insert any unicode character


```r
str_view(c(
  "Saut\nde\nligne",
  "avec\tindentation",
  "\u00b5 mu",
  "\U0001f4a9 (sans commentaires)"
))
```

```
[1] â”‚ Saut
    â”‚ de
    â”‚ ligne
[2] â”‚ avec{\t}indentation
[3] â”‚ Âµ mu
[4] â”‚ ğŸ’© (sans commentaires)
```

You can type `?'"'` at the R console for more details on the possibilities of escape characters.

## Creating text by programming

To create and combine text programmatically, there are three functions in the tidyverse, `str_c` and `str_glue` to work directly on objects (mutate, etc.) and `str_flatten` for cases where we try to summarize text.

The `str_c` function works like the c function, but for pasting chunks of text into a string, rather than pasting numbers into a vector.


```r
str_c("a","b","c")
```

```
[1] "abc"
```

```r
str_c("Salut ",c("Charles","Vincent"))
```

```
[1] "Salut Charles" "Salut Vincent"
```

Its operation is very similar to the `paste0` function, but its handling of missing values and vectors of different lengths (see previous example) is more consistent with all the other functions of the tidyverse.

Each element passed to str_c can of course be an object containing text, rather than the text itself:

```r
nom <- "Charles"
moment <- "aujourd'hui"
str_c("Bonjour ", nom, "! Comment allez-vous ", moment, "?")
```

```
[1] "Bonjour Charles! Comment allez-vous aujourd'hui?"
```

Although practical, this approach can become tedious if you have several pieces of text to put together and each time you have to close the quotation mark, add the comma, open the quotation mark, etc. without forgetting anything.

This is where the str_glue function comes in:

```r
str_glue("Bonjour {nom}, comment allez-vous {moment}?")
```

```
Bonjour Charles, comment allez-vous aujourd'hui?
```

R will automatically replace each word enclosed in braces with the contents of the variable of the same name.


```r
noms <- c("Pierre","Paul","Jacques")
str_glue("Bonjour {noms}, comment allez-vous {moment}?")
```

```
Bonjour Pierre, comment allez-vous aujourd'hui?
Bonjour Paul, comment allez-vous aujourd'hui?
Bonjour Jacques, comment allez-vous aujourd'hui?
```
As you may see, `str_c` and `str_glue` will work great in contexts like a mutate where the function needs to produce a series of strings in response to a vector.

If our operation must imperatively return a single string, then we must use the `str_flatten` function:

```r
str_flatten(noms, ", ")
```

```
[1] "Pierre, Paul, Jacques"
```
You can also control the last separator to make nice enumerations:

```r
str_flatten(noms,", ",last = " et ")
```

```
[1] "Pierre, Paul et Jacques"
```


```r
habitats <- tribble(
  ~Espece,~Habitat,
  "A","dÃ©sert",
  "A","forÃªt",
  "B", "forÃªt",
  "A", "tundra"
)
habitats %>% 
  group_by(Espece) %>% 
  summarize(
    Nombre = n(),
    Liste = str_flatten(Habitat,", ")
  )
```

```
# A tibble: 2 Ã— 3
  Espece Nombre Liste                
  <chr>   <int> <chr>                
1 A           3 dÃ©sert, forÃªt, tundra
2 B           1 forÃªt                
```

# Text extraction
Another extremely common task that occurs in our R analyzes is having to extract textual information from already existing variables.

The tidyr library provides a series of functions designed expressly for this type of situation: the separate_ family, which includes 4 functions, namely:

* `separate_longer_delim`
* `separate_longer_position`
* `separate_wider_delim`
* `separate_wider_position`

In all cases, the functions will analyze the text contained in a variable, and separate it into pieces. Either by creating one observation per piece (_longer), or by creating one column per piece (_wider).

The splitting of the pieces can be based either on a separator (_delim), or on the position of the text (_position)

These functions are very useful, for example, when you have encoded information in the name of the sites in your experience:

```r
experience_a <- tibble(
  nom_site = c("CT01","CT02","CT03","TR01","TR02","TR03")
)
experience_a
```

```
# A tibble: 6 Ã— 1
  nom_site
  <chr>   
1 CT01    
2 CT02    
3 CT03    
4 TR01    
5 TR02    
6 TR03    
```

All you have to do is provide the function with the number of characters in each of the pieces, with the name that this column should have corrected data frame.

```r
experience_a %>% 
  separate_wider_position(nom_site,c(traitement = 2, no_replicat = 2) )
```

```
# A tibble: 6 Ã— 2
  traitement no_replicat
  <chr>      <chr>      
1 CT         01         
2 CT         02         
3 CT         03         
4 TR         01         
5 TR         02         
6 TR         03         
```

If our data had instead been in this format:

```r
experience_b <- tibble(
  nom_site = c("CT-1","CT-10","R-1","R-100")
)
experience_b
```

```
# A tibble: 4 Ã— 1
  nom_site
  <chr>   
1 CT-1    
2 CT-10   
3 R-1     
4 R-100   
```
we could have extracted them based on the presence of the separator, like this:

```r
experience_b %>% 
  separate_wider_delim(nom_site,delim = "-",names = c("traitement","no_replicat"))
```

```
# A tibble: 4 Ã— 2
  traitement no_replicat
  <chr>      <chr>      
1 CT         1          
2 CT         10         
3 R          1          
4 R          100        
```
Finally, it could happen that the information of several observations is
encoded in the same cell:

```r
experience_c <- tibble(
  site = c("A","B"),
  resultats_visites = c("0,0,1","1,0,1"),
  latitude = c(46,47),
  longitude = c(-72,-72.5)
)
experience_c
```

```
# A tibble: 2 Ã— 4
  site  resultats_visites latitude longitude
  <chr> <chr>                <dbl>     <dbl>
1 A     0,0,1                   46     -72  
2 B     1,0,1                   47     -72.5
```
We can then use a _longer function to recreate each observation:

```r
experience_c %>% 
  separate_longer_delim(resultats_visites, delim = ",")
```

```
# A tibble: 6 Ã— 4
  site  resultats_visites latitude longitude
  <chr> <chr>                <dbl>     <dbl>
1 A     0                       46     -72  
2 A     0                       46     -72  
3 A     1                       46     -72  
4 B     1                       47     -72.5
5 B     0                       47     -72.5
6 B     1                       47     -72.5
```
For simpler operations, you can also fetch directly
snippets of text with the str_sub function.

It allows you to use positive position numbers when you want to extract
from the beginning, and negative position numbers when we want to extract from
of the end :

```r
str_sub("LongTexte",5,9)
```

```
[1] "Texte"
```

```r
str_sub("LongTexte",-5, -1)
```

```
[1] "Texte"
```

# Les expressions rÃ©guliÃ¨res (regex)

Maintenant que nous avons vu la plupart des fonctions permettant de traiter le 
texte par programmation, nous allons nous attaquer Ã  une deuxiÃ¨me faÃ§on soit 
les expression rÃ©guliÃ¨res (*regular expressions*), communÃ©ment appelÃ©es par
leur acronyme anglais : regex!

Les regex sont des sÃ©quences de caractÃ¨res permettant de dÃ©finir un patron
de recherche Ã  utiliser, de faÃ§on hyper efficace.

Le prix Ã  payer pour cette efficacitÃ© est que les regex sont parfois difficiles Ã 
lire et Ã  dÃ©boguer. Certains parlent parfois de magie noire, Ã  cause de leur
cÃ´tÃ© un peu obscur et imprÃ©visible. Mais bien maÃ®trisÃ©s, ils sont extrÃªmement
puissants.

## Exploration avec str_view
Pour faciliter notre apprentissage des regex, nous allons utiliser une fonction
qui permet de les tester visuellement, soit la fonction `str_view`.

Pour illustrer nos exemples, nous utiliserons la colonne name de la base de donnÃ©es
msleep, qui est founie avec la librairie ggplot2

```r
head(msleep$name)
```

```
[1] "Cheetah"                    "Owl monkey"                
[3] "Mountain beaver"            "Greater short-tailed shrew"
[5] "Cow"                        "Three-toed sloth"          
```

Pour se simplifier la vie, nous allons par contre extraire tous les noms
dans un nouveau vecteur, que nous allons aussi convertir en minuscules

```r
noms <- msleep$name %>% str_to_lower()
head(noms)
```

```
[1] "cheetah"                    "owl monkey"                
[3] "mountain beaver"            "greater short-tailed shrew"
[5] "cow"                        "three-toed sloth"          
```


Ã€ la base, un regex est une sÃ©quence de caractÃ¨res Ã  chercher : 

```r
str_view(noms,"shrew")
```

```
 [4] â”‚ greater short-tailed <shrew>
[17] â”‚ lesser short-tailed <shrew>
[73] â”‚ musk <shrew>
[79] â”‚ tree <shrew>
```

La fonction str_view nous montre tous les Ã©lÃ©ments du vecteur de noms qui contenaient
la sÃ©quence recherchÃ©e ("shrew"). Remarquez que dans les sorties, la partie qui 
correspondait Ã  notre regex a Ã©tÃ© entourÃ©e de `< >` et, si vous regardez les sorties
dans la console, elle sera aussi d'une autre couleur.

Remarquez que les regex sont sensibles Ã  la casse (aux diffÃ©rences majuscules/minuscules).
Le patron "SHREW" ne retourne par exemple aucun rÃ©sultat : 

```r
str_view(noms, "SHREW")
```

## La construction de sÃ©quences de recherche
Outre les sÃ©quences de caractÃ¨res recherchÃ©s, un regex peut aussi contenir des
mÃ©ta-caractÃ¨res permettant de contrÃ´ler plus prÃ©cisÃ©ment la recherche.

Le premier que nous verrons est le `.` qui, comme un joker, permet de remplacer
n'importe quel caractÃ¨re.

On peut l'utiliser par exemple pour trouver tous les noms contenant le mot gris
en anglais, peut importe qu'il soit Ã©crit gray ou grey : 

```r
str_view(noms,"gr.y")
```

```
[32] â”‚ <gray> seal
[33] â”‚ <gray> hyrax
```

Il existe ensuite trois mÃ©ta-caractÃ¨res permettant de choisir le nombre de fois
que chacun des patrons recherchÃ© doit survenir: 

* `+` : 1 fois ou plus (obligatoire)
* `?` : 0 ou 1 fois (optionnel)
* `*` : 0 ou plus (optionnel avec possible rÃ©pÃ©tition)

Par exemple, tous les noms contenant un a suivi d'au moins un s

```r
str_view(noms, "as+")
```

```
[21] â”‚ <as>ian elephant
[26] â”‚ pat<as> monkey
[47] â”‚ northern gr<ass>hopper mouse
[59] â”‚ c<as>pian seal
[67] â”‚ e<as>tern american mole
[76] â”‚ e<as>tern american chipmunk
```
Remarquez dans ce cas que notre patron contient le 2e s dans "grass hopper"

Avec le ?, la prÃ©sence du caractÃ¨re devient optionnelle. On peut attraper
par exemple tous les noms contenant ham ou am, comme ceci : 

```r
str_view(noms,"h?am")
```

```
[20] â”‚ north <am>erican opossum
[27] â”‚ western <am>erican chipmunk
[40] â”‚ golden <ham>ster
[67] â”‚ eastern <am>erican mole
[76] â”‚ eastern <am>erican chipmunk
```

Enfin, avec l'astÃ©risque, on peut rendre un patron optionnel, et ce, mÃªme si il se rÃ©pÃ¨te.
On peut par exemple chercher tous les noms contenant "oo", ou avec n'importe quel nombre de p
entre les deux o, comme ceci : 

```r
str_view(noms,"op*o")
```

```
[20] â”‚ north american <opo>ssum
[35] â”‚ mong<oo>se lemur
[37] â”‚ thick-tailed <oppo>sum
[54] â”‚ bab<oo>n
[61] â”‚ potor<oo>
```

Les parenthÃ¨ses carrÃ©es, quant Ã  elles, permettent de dÃ©finir une sÃ©rie d'alternatives
pouvait Ãªtre cherchÃ©es. On peut par exemple trouver tous les rats, les chats et les chauve-souris
comme ceci :

```r
str_view(noms,"[cbr]at")
```

```
[16] â”‚ african giant pouched <rat>
[22] â”‚ big brown <bat>
[28] â”‚ domestic <cat>
[43] â”‚ little brown <bat>
[44] â”‚ round-tailed musk<rat>
[64] â”‚ labo<rat>ory <rat>
[68] â”‚ cotton <rat>
[69] â”‚ mole <rat>
```

L'accent circonflexe permet d'inverser la condition de la parenthÃ¨se carrÃ©e. 
On pourrait par exemple chercher toutes les fois oÃ¹ "at" apparaÃ®t, mais que ce
n'est pas un chat ou un rat : 

```r
str_view(noms,"[^cr]at")
```

```
 [4] â”‚ gr<eat>er short-tailed shrew
[11] â”‚ g<oat>
[22] â”‚ big brown <bat>
[26] â”‚ <pat>as monkey
[43] â”‚ little brown <bat>
```

On peut aussi combiner les parenthÃ¨ses carrÃ©es et les mÃ©ta-caractÃ¨res dÃ©finissant les 
nombres d'apparitions. On pourrait par exemple chercher tous les mots contenant deux
voyelles suivies d'une ou plusieurs consonnes, comme ceci : 

```r
str_view(noms,"[aeiou][aeiou][^aeiou]+")
```

```
 [1] â”‚ ch<eet>ah
 [3] â”‚ m<ount><ain b><eav>er
 [4] â”‚ gr<eat>er short-t<ail>ed shrew
 [6] â”‚ thr<ee-t><oed sl>oth
 [7] â”‚ northern fur s<eal>
 [8] â”‚ vesper m<ous>e
[10] â”‚ r<oe d><eer>
[11] â”‚ g<oat>
[12] â”‚ g<uin><ea p>ig
[16] â”‚ african g<iant p><ouch>ed rat
[17] â”‚ lesser short-t<ail>ed shrew
[19] â”‚ tr<ee hyr>ax
[21] â”‚ as<ian >elephant
[25] â”‚ <eur>op<ean h>edgehog
[32] â”‚ gray s<eal>
[35] â”‚ mong<oos>e lemur
[37] â”‚ thick-t<ail>ed opposum
[39] â”‚ mongol<ian g>erbil
[42] â”‚ h<ous>e m<ous>e
[44] â”‚ r<ound-t><ail>ed muskrat
... and 18 more
```
Remarquez que dans plusieurs instances, notre patron a Ã©tÃ© trouvÃ© Ã  plusieurs reprises.
Remarquez aussi que notre dÃ©finition de "consonne" n'est pas tout Ã  fait juste.
Comme les espaces ne sont pas des voyelles, ils sont aussi capturÃ©s par notre patron
de recherche.

Un autre caractÃ¨re spÃ©cial particuliÃ¨rement utile est la barre
verticale (|). Ce dernier permet de dÃ©finir des sÃ©quences alternatives (un OU).
Par exemple, pour trouver tous les Ã©cureuils et les tamias, on pourrait Ã©crire :

```r
str_view(noms,"squirrel|chipmunk")
```

```
[27] â”‚ western american <chipmunk>
[66] â”‚ <squirrel> monkey
[70] â”‚ arctic ground <squirrel>
[71] â”‚ thirteen-lined ground <squirrel>
[72] â”‚ golden-mantled ground <squirrel>
[76] â”‚ eastern american <chipmunk>
```

Remarquez que notre sÃ©quence a aussi dÃ©tectÃ© le Singe-Ã©cureuil. Nous verrons plus 
loin comment remÃ©dier Ã  ce problÃ¨me.

## Fonctions basÃ©es sur les regex
Maintenant que nous avons vu la mÃ©canique de base, nous allons faire un petit
survol des fonctions permettant l'utilisation des regex.

Pour bien illustrer ces fonctions, nous allons nous crÃ©er un petit tableau
de donnÃ©es contenant les noms des animaux en minuscule (comme nous avons
utilisÃ© dans la prÃ©cÃ©dente section) combinÃ© Ã  une autre colonne d'information
pour illustrer l'application sur des tableaux.


```r
tableau <- tibble(
  noms = noms,
  sommeil = msleep$sleep_total
)
```


L'application la plus pratique sera sans aucun doute de combiner le filter
de dplyr avec la fonction str_detect.


```r
tableau %>% 
  filter(str_detect(noms, "squirrel|chipmunk"))
```

```
# A tibble: 6 Ã— 2
  noms                           sommeil
  <chr>                            <dbl>
1 western american chipmunk         14.9
2 squirrel monkey                    9.6
3 arctic ground squirrel            16.6
4 thirteen-lined ground squirrel    13.8
5 golden-mantled ground squirrel    15.9
6 eastern american chipmunk         15.8
```

Une autre chose que l'on voudra souvent faire est de remplacer le patron
trouvÃ© par autre chose. Par exemple, si finalement les experts dÃ©cidaient
que tous les tamias et les Ã©cureuils s'appelaient dÃ©sormais des squimunk, on 
pourrait faire ceci : 

```r
tableau %>% 
  mutate(
    noms = str_replace(noms,"squirrel|chipmunk","squimunk")
  ) %>% slice(70:80)
```

```
# A tibble: 11 Ã— 2
   noms                           sommeil
   <chr>                            <dbl>
 1 arctic ground squimunk            16.6
 2 thirteen-lined ground squimunk    13.8
 3 golden-mantled ground squimunk    15.9
 4 musk shrew                        12.8
 5 pig                                9.1
 6 short-nosed echidna                8.6
 7 eastern american squimunk         15.8
 8 brazilian tapir                    4.4
 9 tenrec                            15.6
10 tree shrew                         8.9
11 bottle-nosed dolphin               5.2
```
Remarquez que j'utilise la fonction `slice` pour vous montrer les lignes
oÃ¹ notre remplacement a Ã©tÃ© fait.

Ã€ l'extrÃªme, on pourrait dÃ©cider de remplacer tous les "e" par une autre lettre : 

```r
tableau %>% 
  mutate(
    noms = str_replace(noms, "e","X")
  )
```

```
# A tibble: 83 Ã— 2
   noms                       sommeil
   <chr>                        <dbl>
 1 chXetah                       12.1
 2 owl monkXy                    17  
 3 mountain bXaver               14.4
 4 grXater short-tailed shrew    14.9
 5 cow                            4  
 6 thrXe-toed sloth              14.4
 7 northXrn fur seal              8.7
 8 vXsper mouse                   7  
 9 dog                           10.1
10 roX deer                       3  
# â€¦ with 73 more rows
```

Comme vous le constatez, str_replace ne change que la premiÃ¨re instance trouvÃ©e.
Pour remplacer toutes les instances, il faut passer par la fonction str_replace_all : 

```r
tableau %>% 
  mutate(
    noms = str_replace_all(noms, "e","X")
  )
```

```
# A tibble: 83 Ã— 2
   noms                       sommeil
   <chr>                        <dbl>
 1 chXXtah                       12.1
 2 owl monkXy                    17  
 3 mountain bXavXr               14.4
 4 grXatXr short-tailXd shrXw    14.9
 5 cow                            4  
 6 thrXX-toXd sloth              14.4
 7 northXrn fur sXal              8.7
 8 vXspXr mousX                   7  
 9 dog                           10.1
10 roX dXXr                       3  
# â€¦ with 73 more rows
```

Si on laisse le deuxiÃ¨me argument vide ("") dans les str_replace, on demande essentiellement
Ã  R d'enlever cette sÃ©quence. Il peut parfois Ãªtre plus Ã©lÃ©gant et lisible dans ces cas de simplement
utiliser la fonction str_remove (ou str_remove_all). On pourrait Ã©liminer tous les e de nos 
donnÃ©es comme ceci : 

```r
tableau %>% 
  mutate(
    noms = str_remove_all(noms, "e")
  )
```

```
# A tibble: 83 Ã— 2
   noms                   sommeil
   <chr>                    <dbl>
 1 chtah                     12.1
 2 owl monky                 17  
 3 mountain bavr             14.4
 4 gratr short-taild shrw    14.9
 5 cow                        4  
 6 thr-tod sloth             14.4
 7 northrn fur sal            8.7
 8 vspr mous                  7  
 9 dog                       10.1
10 ro dr                      3  
# â€¦ with 73 more rows
```

Il existe des dizaines d'autres fonctions permettant de travailler avec des regex,
entre autres `str_subset`, `str_which` et `str_count`que je vous encourage fortement 
Ã  explorer par vous-mÃªme


## CaractÃ¨res d'Ã©chappement (encore!)
Bon, alors, si j'avais Ã  vous demander d'Ã©crire un regex pour dÃ©tecter un point (.), 
vous feriez quoi?


```r
texte <- "PremiÃ¨re phrase. DeuxiÃ¨me phrase."
str_view(texte,".")
```

```
[1] â”‚ <P><r><e><m><i><Ã¨><r><e>< ><p><h><r><a><s><e><.>< ><D><e><u><x><i><Ã¨><m><e>< ><p><h><r><a><s><e><.>
```
Ã‰videmment non. Un point est un joker, qui peut remplacer n'importe quel caractÃ¨re.

Peut-Ãªtre avec un caractÃ¨re d'Ã©chappement?

```r
str_view(texte,"\.")
```

```
Error: '\.' is an unrecognized escape in character string starting ""\."
```
Ah non, Ã§a ne marche pas parce que, au moment d'Ã©crire la chaÃ®ne de caractÃ¨res,
R remplace les `\`-quelquechose en les encodant, et `\.`, Ã§a ne veut rien dire pour lui.

Alors, oui, il faut utiliser `\\.` pour dÃ©tecter un simple petit point!

```r
str_view(texte,"\\.")
```

```
[1] â”‚ PremiÃ¨re phrase<.> DeuxiÃ¨me phrase<.>
```

Un backslash au niveau de R et un backslash au niveau de l'interprÃ©tation du regex.

Maintenant, si on se prÃ©pare une chaÃ®ne de caractÃ¨re avec un backslash dedans : 

```r
bs <- "a\\b"
str_view(bs)
```

```
[1] â”‚ a\b
```
Comment on fait pour le retrouver avec un regex?

Eh oui, Ã§a nous prendra 4 backslash pour en trouver un seul.

```r
str_view(bs, "\\\\")
```

```
[1] â”‚ a<\>b
```

Au moment de crÃ©er la chaÃ®ne de caractÃ¨res dans R, on en perd 2 Ã  l'encodage, 
puis au niveau du regex, on en perd un dernier!

Si on veut se simplifier un peu la vie, on peut se rappeller que R nous permet
de crÃ©er des chaÃ®nes de caractÃ¨res brutes, qui ne passent pas par l'Ã©tape d'encodage : 

```r
bs2 <- r"(a\n)"
str_view(bs2, r"(\\)")
```

```
[1] â”‚ a<\>n
```

Ce n'est pas idÃ©al, mais Ã§a Ã©limine au moins un niveau d'abstraction.

## CaractÃ¨res spÃ©ciaux
Tout comme les regex comprennent leur propre syntaxe, ils comprennent aussi
une sÃ©rie de caractÃ¨res spÃ©ciaux qui leur sont propres.

Voyons tout d'abord les caractÃ¨res d'ancrage. Les regex comprennent deux
caractÃ¨res d'ancrage soit `^` et `$` dÃ©signant respectivement le dÃ©but et la 
fin d'une chaÃ®ne de caractÃ¨res

On peut par exemple utiliser un ancrage pour trouver tous les noms de mammifÃ¨res
qui se terminent par squirrel, et ainsi Ã©liminer de nos rÃ©sultats le singe-Ã©cureuil : 

```r
str_view(noms, "squirrel")
```

```
[66] â”‚ <squirrel> monkey
[70] â”‚ arctic ground <squirrel>
[71] â”‚ thirteen-lined ground <squirrel>
[72] â”‚ golden-mantled ground <squirrel>
```
vs.

```r
str_view(noms, "squirrel$")
```

```
[70] â”‚ arctic ground <squirrel>
[71] â”‚ thirteen-lined ground <squirrel>
[72] â”‚ golden-mantled ground <squirrel>
```

Si on combine les deux caractÃ¨res d'ancrage, on s'assure que la chaÃ®ne de caractÃ¨res
ne contient que le texte demandÃ©. Rien de plus, rien de moins.


```r
str_view(noms,"pig")
```

```
[12] â”‚ guinea <pig>
[74] â”‚ <pig>
```
vs.

```r
str_view(noms, "^pig$")
```

```
[74] â”‚ <pig>
```

Les regex comprennent aussi des caractÃ¨res spÃ©ciaux nous Ã©vitant les longues Ã©numÃ©rations. On peut par exemple utiliser `\w` pour trouver n'importe quelle lettre ou chiffre.

Ainsi, pour trouver tous les noms d'espÃ¨ces composÃ©s de deux mots, on pourrait
faire ceci : 

```r
str_view(noms,"^\\w+ \\w+$")
```

```
 [2] â”‚ <owl monkey>
 [3] â”‚ <mountain beaver>
 [8] â”‚ <vesper mouse>
[10] â”‚ <roe deer>
[12] â”‚ <guinea pig>
[19] â”‚ <tree hyrax>
[21] â”‚ <asian elephant>
[25] â”‚ <european hedgehog>
[26] â”‚ <patas monkey>
[28] â”‚ <domestic cat>
[31] â”‚ <pilot whale>
[32] â”‚ <gray seal>
[33] â”‚ <gray hyrax>
[35] â”‚ <mongoose lemur>
[36] â”‚ <african elephant>
[39] â”‚ <mongolian gerbil>
[40] â”‚ <golden hamster>
[42] â”‚ <house mouse>
[45] â”‚ <slow loris>
[55] â”‚ <desert hedgehog>
... and 14 more
```

Il existe aussi sÃ©rie d'autres caractÃ¨res semblables, dont voici un aperÃ§u : 

* `\d` : n'importe quel chiffre
* `\D` : tout sauf un chiffre
* `\s` : n'importe quel caractÃ¨re d'espacement (espace, saut de ligne, indentation)
* `\S` : tout sauf un espacement
* `\w` : n'importe quelle lettre ou chiffre
* `\W` : tout ce qui n'est pas une lettre ou un chiffre

Au delÃ  des caractÃ¨res `+`, `?` et `*`, les regex nous permettent aussi un contrÃ´le
plus fin du nombre de rÃ©pÃ©tition d'un patron, Ã  l'aide des accolades. Pour trouver tous les noms commenÃ§ant par un mots de 3 lettres suivi d'un espace, on pourrait faire ceci :

```r
str_view(noms,"^\\w{3}\\s")
```

```
 [2] â”‚ <owl >monkey
[10] â”‚ <roe >deer
[22] â”‚ <big >brown bat
[83] â”‚ <red >fox
```

Remarquez qu'il existe aussi un caractÃ¨re spÃ©cial permettant de dÃ©tecter les
frontiÃ¨res entourant un mot : `\b`.

Si on veut trouver tous les noms comprenant un mot d'exactement 3 lettres, on pourrait faire ceci : 

```r
str_view(noms, "\\b\\w{3}\\b")
```

```
 [2] â”‚ <owl> monkey
 [5] â”‚ <cow>
 [7] â”‚ northern <fur> seal
 [9] â”‚ <dog>
[10] â”‚ <roe> deer
[12] â”‚ guinea <pig>
[16] â”‚ african giant pouched <rat>
[22] â”‚ <big> brown <bat>
[28] â”‚ domestic <cat>
[43] â”‚ little brown <bat>
[64] â”‚ laboratory <rat>
[68] â”‚ cotton <rat>
[69] â”‚ mole <rat>
[74] â”‚ <pig>
[82] â”‚ arctic <fox>
[83] â”‚ <red> <fox>
```

Si on ne mentionne qu'un chiffre, les accolades cherchent un nombre exact de 
dÃ©tections, mais on peut aussi spÃ©cifier deux valeurs, qui donneront les bornes
du nombre de dÃ©tection acceptable.

Par exemple, pour trouver tous les noms d'animaux comprenant un mot de 3 Ã  5 lettres,
on Ã©crirait ceci : 

```r
str_view(noms, "\\b\\w{3,5}\\b")
```

```
 [2] â”‚ <owl> monkey
 [4] â”‚ greater <short>-tailed <shrew>
 [5] â”‚ <cow>
 [6] â”‚ <three>-<toed> <sloth>
 [7] â”‚ northern <fur> <seal>
 [8] â”‚ vesper <mouse>
 [9] â”‚ <dog>
[10] â”‚ <roe> <deer>
[11] â”‚ <goat>
[12] â”‚ guinea <pig>
[15] â”‚ <star>-<nosed> <mole>
[16] â”‚ african <giant> pouched <rat>
[17] â”‚ lesser <short>-tailed <shrew>
[18] â”‚ <long>-<nosed> armadillo
[19] â”‚ <tree> <hyrax>
[20] â”‚ <north> american opossum
[21] â”‚ <asian> elephant
[22] â”‚ <big> <brown> <bat>
[23] â”‚ <horse>
[26] â”‚ <patas> monkey
... and 37 more
```

## PrioritÃ© d'opÃ©ration

Tout comme en mathÃ©matiques, l'Ã©valuation d'un regex ne s'effectue pas nÃ©cessairement de gauche Ã  droite. Il existe un ordre de prioritÃ© entre les opÃ©rations.

En rÃ¨gle gÃ©nÃ©rale, les caractÃ¨res contrÃ´lant le nombre de rÃ©pÃ©titions ont prÃ©sÃ©ance
sur ceux dÃ©finissant des alternatives.

Par exemple `ab+` sera interprÃ©tÃ© comme `a(b+)`. `^a|b$` sera interprÃ©tÃ© comme `(^a)|(b$)`, etc.

Contrairement Ã  l'algÃ¨bre, ces prioritÃ©s sont trÃ¨s difficiles Ã  retenir, et le plus
simple est probablement d'utiliser autant de parenthÃ¨ses que nÃ©cessaire pour
clarifier le patron recherchÃ©.

## Regroupements et rÃ©utilisation
Outre la clarification des prioritÃ©s, les parenthÃ¨ses ont une autre utilisation
particuliÃ¨re dans les regex : elles crÃ©ent des groupes qui peuvent Ãªtre rÃ©utilisÃ©s. Chacun des groupes dÃ©finis par les parenthÃ¨ses est numÃ©rotÃ© automatiquement par R. Ces numÃ©ros
peuvent ensuite Ãªtre utilisÃ©s ailleurs dans le regex. Le premier groupe
sera nommÃ© `\1`, le deuxiÃ¨me `\2`, etc.

On peut par exemple trouver tous les animaux dont le nom comporte une double lettre, comme ceci : 

```r
str_view(noms,"(\\w)\\1")
```

```
 [1] â”‚ ch<ee>tah
 [6] â”‚ thr<ee>-toed sloth
[10] â”‚ roe d<ee>r
[14] â”‚ chinchi<ll>a
[17] â”‚ le<ss>er short-tailed shrew
[18] â”‚ long-nosed armadi<ll>o
[19] â”‚ tr<ee> hyrax
[20] â”‚ north american opo<ss>um
[30] â”‚ gira<ff>e
[35] â”‚ mong<oo>se lemur
[37] â”‚ thick-tailed o<pp>osum
[43] â”‚ li<tt>le brown bat
[47] â”‚ northern gra<ss>ho<pp>er mouse
[48] â”‚ ra<bb>it
[49] â”‚ sh<ee>p
[50] â”‚ chimpanz<ee>
[54] â”‚ bab<oo>n
[56] â”‚ po<tt>o
[57] â”‚ d<ee>r mouse
[60] â”‚ co<mm>on porpoise
... and 9 more
```
Le `\w` attrape une lettre, les parenthÃ¨ses crÃ©ent un groupe (ici le numÃ©ro 1),
et ensuite un rÃ©utilise ce groupe pour crÃ©er le doublon.

Par le mÃªme principe, on peut aussi trouver tous les noms qui commencent et 
finissent par la mÃªme lettre : 

```r
str_view(noms,"^(\\w).*\\1$")
```

```
[10] â”‚ <roe deer>
[12] â”‚ <guinea pig>
[45] â”‚ <slow loris>
[67] â”‚ <eastern american mole>
```

La rÃ©utilisation de patrons est aussi applicable avec la fonction `str_replace`.

Elle peut permettre par exemple d'inverser les deux premiers mots de chaque nom : 

```r
str_replace(noms,"^(\\w+)\\s(\\w+)(.*)", "\\2 \\1\\3")
```

```
 [1] "cheetah"                        "monkey owl"                    
 [3] "beaver mountain"                "short greater-tailed shrew"    
 [5] "cow"                            "three-toed sloth"              
 [7] "fur northern seal"              "mouse vesper"                  
 [9] "dog"                            "deer roe"                      
[11] "goat"                           "pig guinea"                    
[13] "grivet"                         "chinchilla"                    
[15] "star-nosed mole"                "giant african pouched rat"     
[17] "short lesser-tailed shrew"      "long-nosed armadillo"          
[19] "hyrax tree"                     "american north opossum"        
[21] "elephant asian"                 "brown big bat"                 
[23] "horse"                          "donkey"                        
[25] "hedgehog european"              "monkey patas"                  
[27] "american western chipmunk"      "cat domestic"                  
[29] "galago"                         "giraffe"                       
[31] "whale pilot"                    "seal gray"                     
[33] "hyrax gray"                     "human"                         
[35] "lemur mongoose"                 "elephant african"              
[37] "thick-tailed opposum"           "macaque"                       
[39] "gerbil mongolian"               "hamster golden"                
[41] "vole "                          "mouse house"                   
[43] "brown little bat"               "round-tailed muskrat"          
[45] "loris slow"                     "degu"                          
[47] "grasshopper northern mouse"     "rabbit"                        
[49] "sheep"                          "chimpanzee"                    
[51] "tiger"                          "jaguar"                        
[53] "lion"                           "baboon"                        
[55] "hedgehog desert"                "potto"                         
[57] "mouse deer"                     "phalanger"                     
[59] "seal caspian"                   "porpoise common"               
[61] "potoroo"                        "armadillo giant"               
[63] "hyrax rock"                     "rat laboratory"                
[65] "striped african mouse"          "monkey squirrel"               
[67] "american eastern mole"          "rat cotton"                    
[69] "rat mole"                       "ground arctic squirrel"        
[71] "thirteen-lined ground squirrel" "golden-mantled ground squirrel"
[73] "shrew musk"                     "pig"                           
[75] "short-nosed echidna"            "american eastern chipmunk"     
[77] "tapir brazilian"                "tenrec"                        
[79] "shrew tree"                     "bottle-nosed dolphin"          
[81] "genet"                          "fox arctic"                    
[83] "fox red"                       
```
Nous avons ici 3 duos de parenthÃ¨ses, donc 3 groupes. Le premier attrape le
premier mot (`\w+`), le deuxiÃ¨me le second mot (encore `\w+`) et le dernier
attrape tout le reste (`.*`). Ensuite, on reconstruit une chaÃ®ne de caractÃ¨res,
mais en plaÃ§ant le deuxiÃ¨me groupe (`\2`) avant le premier (`\1`).

# Mise en garde
Comme dit si bien Spider-man : Ã€ grand pouvoir correspond grande responsabilitÃ©.

C'est particuliÃ¨rement vrai lorsque l'on parle de regex. Vaut mieux y aller avec modÃ©ration. Il peut parfois Ãªtre plus lisible pour votre "vous" futur de sÃ©parer
ce que vous avez Ã  faire en quelques opÃ©rations simples et lisibles, plutÃ´t que
d'essayer de tout faire dans un regex.

Je vous prÃ©sente en conclusion un regex classique, utilisÃ© dans une librairie
du langage de programmation Perl pour valider si une adresse de courriel est 
valide ou non (https://metacpan.org/release/RJBS/Email-Valid-1.200/source/lib/Email/Valid.pm) : 

```perl
[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\
xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xf
f\n\015()]*)*\)[\040\t]*)*(?:(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\x
ff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015
"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\
xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80
-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*
)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\
\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\
x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x8
0-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n
\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x
80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^
\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040
\t]*)*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([
^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\
\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\
x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-
\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()
]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\
x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\04
0\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\
n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\
015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?!
[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\
]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\
x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\01
5()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*|(?:[^(\040)<>@,;:".
\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]
)|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^
()<>@,;:".\\\[\]\x80-\xff\000-\010\012-\037]*(?:(?:\([^\\\x80-\xff\n\0
15()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][
^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)|"[^\\\x80-\xff\
n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^()<>@,;:".\\\[\]\
x80-\xff\000-\010\012-\037]*)*<[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?
:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-
\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:@[\040\t]*
(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015
()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()
]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\0
40)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\
[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\
xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*
)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80
-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x
80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t
]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\
\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])
*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x
80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80
-\xff\n\015()]*)*\)[\040\t]*)*)*(?:,[\040\t]*(?:\([^\\\x80-\xff\n\015(
)]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\
\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*@[\040\t
]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\0
15()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015
()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(
\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|
\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80
-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()
]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x
80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^
\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040
\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".
\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff
])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\
\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x
80-\xff\n\015()]*)*\)[\040\t]*)*)*)*:[\040\t]*(?:\([^\\\x80-\xff\n\015
()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\
\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)?(?:[^
(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-
\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\
n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|
\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))
[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff
\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\x
ff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(
?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\
000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\
xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\x
ff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)
*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*@[\040\t]*(?:\([^\\\x80-\x
ff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-
\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)
*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\
]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]
)[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-
\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\x
ff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(
?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80
-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<
>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x8
0-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:
\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]
*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)
*\)[\040\t]*)*)*>)
```
# RÃ©fÃ©rences

La plupart du matÃ©riel de cet atelier est fortement inspirÃ© des chapitres en construction de la prochaine Ã©dition de R for Data Science de Hadley Wickham, disponibles en ligne ici :

<https://r4ds.hadley.nz/strings.html>

<https://r4ds.hadley.nz/regexps.html>
