---
layout: default
category: Programming
thumbnail: stringr.png
title: "Strings manipulations in R"
author: "Charles Martin"
date: "2023-03-09"
lang: en
output:
  html_document:
    highlight: haddock
    keep_md: yes
    theme: readable
    toc: yes
    self_contained: true
    toc_float: true	
---

# Strings manipulations in R
{:.no_toc}

## Charles Martin
{:.no_toc}

## March 2023
{:.no_toc}

* TOC
{:toc}


#Required Libraries

This workshop will require recent versions of the readr (minimum version 2.1), stringr (minimum version 1.5), tidyr (minimum version 1.3) and dplyr libraries. You can either enable them individually, or enable the tidyverse meta-library:

```r
library(tidyverse)
```

```
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──
✔ ggplot2 3.4.0      ✔ purrr   1.0.1 
✔ tibble  3.1.8      ✔ dplyr   1.0.10
✔ tidyr   1.3.0      ✔ stringr 1.5.0 
✔ readr   2.1.2      ✔ forcats 0.5.2 
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
```

# How is text constructed in R
Before embarking on the manipulation of text *per se*, it is important to understand the nature of text in R and how to construct it.

## How text is encoded in the computer
In R's memory, in CSV files, etc. the text is stored in a series of hexadecimal codes. We can indeed see the corresponding codes with the charToRaw function:


```r
charToRaw("Charles")
```

```
[1] 43 68 61 72 6c 65 73
```

The “C” is encoded with 43, the “h” with 68, etc.

If we do the mathematics of the thing, we quickly realize that this system can only represent 16*16 = 256 symbols. This worked well at a time when Americans had a hand in computing, but doesn't work at all for encoding text from any language in the world.

In the 1980s-1990s, a series of standards were developed to allow the encoding of characters other than English. Among other things, ISO-8859-1 (Latin1) allowed the encoding of most characters used in Western Europe, Latin2 in Eastern Europe, etc.

Today, there is an international standard, called UTF-8, which makes it possible to encode all imaginable characters, even Emojis!

Most modern software uses this encoding and the use of accents in files is no longer a problem. However, some older applications and some files produced some time ago do not necessarily adhere to this convention.

It is for this reason that sometimes, when loading a CSV file, you will see a series of weird characters in your data:

```r
read_csv("Latin1.csv")
```

```
Rows: 2 Columns: 3
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (1): Col3
dbl (2): Col1, Col2

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```
# A tibble: 2 × 3
   Col1  Col2 Col3            
  <dbl> <dbl> <chr>           
1     1     2 "All\xf4"       
2     3     4 "\xc0 la place?"
```
With trial and error, we can try to *guess* the correct encoding and specify it at load time:

```r
read_csv("Latin1.csv",locale = locale(encoding = "Windows-1252"))
```

```
Rows: 2 Columns: 3
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (1): Col3
dbl (2): Col1, Col2

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```
# A tibble: 2 × 3
   Col1  Col2 Col3       
  <dbl> <dbl> <chr>      
1     1     2 Allô       
2     3     4 À la place?
```

```r
read_csv("Latin1.csv",locale = locale(encoding = "Latin1"))
```

```
Rows: 2 Columns: 3
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
chr (1): Col3
dbl (2): Col1, Col2

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```
# A tibble: 2 × 3
   Col1  Col2 Col3       
  <dbl> <dbl> <chr>      
1     1     2 Allô       
2     3     4 À la place?
```

Usually, if you try Latin1, UTF-8, or Windows-1252, you're pretty sure you've got the right one.

Recent versions of the readr library now come with a feature that lets you let the computer do the dirty work for you:

```r
guess_encoding("Latin1.csv")
```

```
# A tibble: 2 × 2
  encoding   confidence
  <chr>           <dbl>
1 ISO-8859-1       0.62
2 ISO-8859-2       0.41
```

## Manual text creation
Now, how can one do to create text in R?

The easiest way is to create a string object, like this:



## Création manuelle de texte
Maintenant, comment peut-on faire pour créer du texte dans R?

La façon la plus simple est de créer un objet chaîne de caractères, comme ceci : 

```r
chaine1 <- "Il faut l'essayer"
chaine2 <- 'Voici un autre "essai"'
```

Note that we can use the single or double quote to start and end our sequence.

In general, it is recommended to use the double quote, unless your character string contains more than one.

You can also include a double quote in a sequence started with a double quote, by using an escape character, i.e. the backslash (\):

```r
chaine3 <- "Je contient un \" et ça fonctionne tout de même"
```

Therefore, if you want to produce a backslash in a string, you must precede it with another backslash:

```r
backslash <- "\\"
```

Note that if you send one of these strings to the console, you will see the escape character:

```r
chaine3
```

```
[1] "Je contient un \" et ça fonctionne tout de même"
```

```r
backslash
```

```
[1] "\\"
```
This happens because, by default, R's print function (called implicitly) gives us not what it sees as text, but what we should type to reconstruct it.

If we want to see the true representation of the text (as we will see in graphics, etc.), we can use the str_view function. Compare these two outputs:

```r
print(c(chaine1, chaine2, chaine3))
```

```
[1] "Il faut l'essayer"                              
[2] "Voici un autre \"essai\""                       
[3] "Je contient un \" et ça fonctionne tout de même"
```

```r
str_view(c(chaine1, chaine2, chaine3))
```

```
[1] │ Il faut l'essayer
[2] │ Voici un autre "essai"
[3] │ Je contient un " et ça fonctionne tout de même
```

It is also possible to create so-called “raw” character strings, for which, when they are created, R does not try to manage escape characters. To do this, we must start our string with `r"(` and end it with `)"`

```r
complexe <- r"(L'apostrophe, le \ et même les "guillemets" ne posent plus de problèmes)"
str_view(complexe)
```

```
[1] │ L'apostrophe, le \ et même les "guillemets" ne posent plus de problèmes
```
As needed `r"()"` can be replaced with `r"[]"`, `r"{}"`, etc.

## Escape characters

Besides `\"` `\'` and `\\`, there are a series of other special characters when constructing text in R.

Among others : 

* `\n` adds line break
* `\t` adds an indent (tab)
* and `\u` et `\U` allow us to insert any unicode character


```r
str_view(c(
  "Saut\nde\nligne",
  "avec\tindentation",
  "\u00b5 mu",
  "\U0001f4a9 (sans commentaires)"
))
```

```
[1] │ Saut
    │ de
    │ ligne
[2] │ avec{\t}indentation
[3] │ µ mu
[4] │ 💩 (sans commentaires)
```

You can type `?'"'` at the R console for more details on the possibilities of escape characters.

## Creating text by programming

To create and combine text programmatically, there are three functions in the tidyverse, `str_c` and `str_glue` to work directly on objects (mutate, etc.) and `str_flatten` for cases where we try to summarize text.

The `str_c` function works like the c function, but for pasting chunks of text into a string, rather than pasting numbers into a vector.


```r
str_c("a","b","c")
```

```
[1] "abc"
```

```r
str_c("Salut ",c("Charles","Vincent"))
```

```
[1] "Salut Charles" "Salut Vincent"
```

Its operation is very similar to the `paste0` function, but its handling of missing values and vectors of different lengths (see previous example) is more consistent with all the other functions of the tidyverse.

Each element passed to str_c can of course be an object containing text, rather than the text itself:

```r
nom <- "Charles"
moment <- "aujourd'hui"
str_c("Bonjour ", nom, "! Comment allez-vous ", moment, "?")
```

```
[1] "Bonjour Charles! Comment allez-vous aujourd'hui?"
```

Although practical, this approach can become tedious if you have several pieces of text to put together and each time you have to close the quotation mark, add the comma, open the quotation mark, etc. without forgetting anything.

This is where the str_glue function comes in:

```r
str_glue("Bonjour {nom}, comment allez-vous {moment}?")
```

```
Bonjour Charles, comment allez-vous aujourd'hui?
```

R will automatically replace each word enclosed in braces with the contents of the variable of the same name.


```r
noms <- c("Pierre","Paul","Jacques")
str_glue("Bonjour {noms}, comment allez-vous {moment}?")
```

```
Bonjour Pierre, comment allez-vous aujourd'hui?
Bonjour Paul, comment allez-vous aujourd'hui?
Bonjour Jacques, comment allez-vous aujourd'hui?
```
As you may see, `str_c` and `str_glue` will work great in contexts like a mutate where the function needs to produce a series of strings in response to a vector.

If our operation must imperatively return a single string, then we must use the `str_flatten` function:

```r
str_flatten(noms, ", ")
```

```
[1] "Pierre, Paul, Jacques"
```
You can also control the last separator to make nice enumerations:

```r
str_flatten(noms,", ",last = " et ")
```

```
[1] "Pierre, Paul et Jacques"
```


```r
habitats <- tribble(
  ~Espece,~Habitat,
  "A","désert",
  "A","forêt",
  "B", "forêt",
  "A", "tundra"
)
habitats %>% 
  group_by(Espece) %>% 
  summarize(
    Nombre = n(),
    Liste = str_flatten(Habitat,", ")
  )
```

```
# A tibble: 2 × 3
  Espece Nombre Liste                
  <chr>   <int> <chr>                
1 A           3 désert, forêt, tundra
2 B           1 forêt                
```

# Text extraction
Another extremely common task that occurs in our R analyzes is having to extract textual information from already existing variables.

The tidyr library provides a series of functions designed expressly for this type of situation: the separate_ family, which includes 4 functions, namely:

* `separate_longer_delim`
* `separate_longer_position`
* `separate_wider_delim`
* `separate_wider_position`

In all cases, the functions will analyze the text contained in a variable, and separate it into pieces. Either by creating one observation per piece (_longer), or by creating one column per piece (_wider).

The splitting of the pieces can be based either on a separator (_delim), or on the position of the text (_position)

These functions are very useful, for example, when you have encoded information in the name of the sites in your experience:

```r
experience_a <- tibble(
  nom_site = c("CT01","CT02","CT03","TR01","TR02","TR03")
)
experience_a
```

```
# A tibble: 6 × 1
  nom_site
  <chr>   
1 CT01    
2 CT02    
3 CT03    
4 TR01    
5 TR02    
6 TR03    
```

All you have to do is provide the function with the number of characters in each of the pieces, with the name that this column should have corrected data frame.

```r
experience_a %>% 
  separate_wider_position(nom_site,c(traitement = 2, no_replicat = 2) )
```

```
# A tibble: 6 × 2
  traitement no_replicat
  <chr>      <chr>      
1 CT         01         
2 CT         02         
3 CT         03         
4 TR         01         
5 TR         02         
6 TR         03         
```

If our data had instead been in this format:

```r
experience_b <- tibble(
  nom_site = c("CT-1","CT-10","R-1","R-100")
)
experience_b
```

```
# A tibble: 4 × 1
  nom_site
  <chr>   
1 CT-1    
2 CT-10   
3 R-1     
4 R-100   
```
we could have extracted them based on the presence of the separator, like this:

```r
experience_b %>% 
  separate_wider_delim(nom_site,delim = "-",names = c("traitement","no_replicat"))
```

```
# A tibble: 4 × 2
  traitement no_replicat
  <chr>      <chr>      
1 CT         1          
2 CT         10         
3 R          1          
4 R          100        
```
Finally, it could happen that the information of several observations is
encoded in the same cell:

```r
experience_c <- tibble(
  site = c("A","B"),
  resultats_visites = c("0,0,1","1,0,1"),
  latitude = c(46,47),
  longitude = c(-72,-72.5)
)
experience_c
```

```
# A tibble: 2 × 4
  site  resultats_visites latitude longitude
  <chr> <chr>                <dbl>     <dbl>
1 A     0,0,1                   46     -72  
2 B     1,0,1                   47     -72.5
```
We can then use a _longer function to recreate each observation:

```r
experience_c %>% 
  separate_longer_delim(resultats_visites, delim = ",")
```

```
# A tibble: 6 × 4
  site  resultats_visites latitude longitude
  <chr> <chr>                <dbl>     <dbl>
1 A     0                       46     -72  
2 A     0                       46     -72  
3 A     1                       46     -72  
4 B     1                       47     -72.5
5 B     0                       47     -72.5
6 B     1                       47     -72.5
```
For simpler operations, you can also fetch directly
snippets of text with the str_sub function.

It allows you to use positive position numbers when you want to extract
from the beginning, and negative position numbers when we want to extract from
of the end :

```r
str_sub("LongTexte",5,9)
```

```
[1] "Texte"
```

```r
str_sub("LongTexte",-5, -1)
```

```
[1] "Texte"
```

# Les expressions régulières (regex)

Maintenant que nous avons vu la plupart des fonctions permettant de traiter le 
texte par programmation, nous allons nous attaquer à une deuxième façon soit 
les expression régulières (*regular expressions*), communément appelées par
leur acronyme anglais : regex!

Les regex sont des séquences de caractères permettant de définir un patron
de recherche à utiliser, de façon hyper efficace.

Le prix à payer pour cette efficacité est que les regex sont parfois difficiles à
lire et à déboguer. Certains parlent parfois de magie noire, à cause de leur
côté un peu obscur et imprévisible. Mais bien maîtrisés, ils sont extrêmement
puissants.

## Exploration avec str_view
Pour faciliter notre apprentissage des regex, nous allons utiliser une fonction
qui permet de les tester visuellement, soit la fonction `str_view`.

Pour illustrer nos exemples, nous utiliserons la colonne name de la base de données
msleep, qui est founie avec la librairie ggplot2

```r
head(msleep$name)
```

```
[1] "Cheetah"                    "Owl monkey"                
[3] "Mountain beaver"            "Greater short-tailed shrew"
[5] "Cow"                        "Three-toed sloth"          
```

Pour se simplifier la vie, nous allons par contre extraire tous les noms
dans un nouveau vecteur, que nous allons aussi convertir en minuscules

```r
noms <- msleep$name %>% str_to_lower()
head(noms)
```

```
[1] "cheetah"                    "owl monkey"                
[3] "mountain beaver"            "greater short-tailed shrew"
[5] "cow"                        "three-toed sloth"          
```


À la base, un regex est une séquence de caractères à chercher : 

```r
str_view(noms,"shrew")
```

```
 [4] │ greater short-tailed <shrew>
[17] │ lesser short-tailed <shrew>
[73] │ musk <shrew>
[79] │ tree <shrew>
```

La fonction str_view nous montre tous les éléments du vecteur de noms qui contenaient
la séquence recherchée ("shrew"). Remarquez que dans les sorties, la partie qui 
correspondait à notre regex a été entourée de `< >` et, si vous regardez les sorties
dans la console, elle sera aussi d'une autre couleur.

Remarquez que les regex sont sensibles à la casse (aux différences majuscules/minuscules).
Le patron "SHREW" ne retourne par exemple aucun résultat : 

```r
str_view(noms, "SHREW")
```

## La construction de séquences de recherche
Outre les séquences de caractères recherchés, un regex peut aussi contenir des
méta-caractères permettant de contrôler plus précisément la recherche.

Le premier que nous verrons est le `.` qui, comme un joker, permet de remplacer
n'importe quel caractère.

On peut l'utiliser par exemple pour trouver tous les noms contenant le mot gris
en anglais, peut importe qu'il soit écrit gray ou grey : 

```r
str_view(noms,"gr.y")
```

```
[32] │ <gray> seal
[33] │ <gray> hyrax
```

Il existe ensuite trois méta-caractères permettant de choisir le nombre de fois
que chacun des patrons recherché doit survenir: 

* `+` : 1 fois ou plus (obligatoire)
* `?` : 0 ou 1 fois (optionnel)
* `*` : 0 ou plus (optionnel avec possible répétition)

Par exemple, tous les noms contenant un a suivi d'au moins un s

```r
str_view(noms, "as+")
```

```
[21] │ <as>ian elephant
[26] │ pat<as> monkey
[47] │ northern gr<ass>hopper mouse
[59] │ c<as>pian seal
[67] │ e<as>tern american mole
[76] │ e<as>tern american chipmunk
```
Remarquez dans ce cas que notre patron contient le 2e s dans "grass hopper"

Avec le ?, la présence du caractère devient optionnelle. On peut attraper
par exemple tous les noms contenant ham ou am, comme ceci : 

```r
str_view(noms,"h?am")
```

```
[20] │ north <am>erican opossum
[27] │ western <am>erican chipmunk
[40] │ golden <ham>ster
[67] │ eastern <am>erican mole
[76] │ eastern <am>erican chipmunk
```

Enfin, avec l'astérisque, on peut rendre un patron optionnel, et ce, même si il se répète.
On peut par exemple chercher tous les noms contenant "oo", ou avec n'importe quel nombre de p
entre les deux o, comme ceci : 

```r
str_view(noms,"op*o")
```

```
[20] │ north american <opo>ssum
[35] │ mong<oo>se lemur
[37] │ thick-tailed <oppo>sum
[54] │ bab<oo>n
[61] │ potor<oo>
```

Les parenthèses carrées, quant à elles, permettent de définir une série d'alternatives
pouvait être cherchées. On peut par exemple trouver tous les rats, les chats et les chauve-souris
comme ceci :

```r
str_view(noms,"[cbr]at")
```

```
[16] │ african giant pouched <rat>
[22] │ big brown <bat>
[28] │ domestic <cat>
[43] │ little brown <bat>
[44] │ round-tailed musk<rat>
[64] │ labo<rat>ory <rat>
[68] │ cotton <rat>
[69] │ mole <rat>
```

L'accent circonflexe permet d'inverser la condition de la parenthèse carrée. 
On pourrait par exemple chercher toutes les fois où "at" apparaît, mais que ce
n'est pas un chat ou un rat : 

```r
str_view(noms,"[^cr]at")
```

```
 [4] │ gr<eat>er short-tailed shrew
[11] │ g<oat>
[22] │ big brown <bat>
[26] │ <pat>as monkey
[43] │ little brown <bat>
```

On peut aussi combiner les parenthèses carrées et les méta-caractères définissant les 
nombres d'apparitions. On pourrait par exemple chercher tous les mots contenant deux
voyelles suivies d'une ou plusieurs consonnes, comme ceci : 

```r
str_view(noms,"[aeiou][aeiou][^aeiou]+")
```

```
 [1] │ ch<eet>ah
 [3] │ m<ount><ain b><eav>er
 [4] │ gr<eat>er short-t<ail>ed shrew
 [6] │ thr<ee-t><oed sl>oth
 [7] │ northern fur s<eal>
 [8] │ vesper m<ous>e
[10] │ r<oe d><eer>
[11] │ g<oat>
[12] │ g<uin><ea p>ig
[16] │ african g<iant p><ouch>ed rat
[17] │ lesser short-t<ail>ed shrew
[19] │ tr<ee hyr>ax
[21] │ as<ian >elephant
[25] │ <eur>op<ean h>edgehog
[32] │ gray s<eal>
[35] │ mong<oos>e lemur
[37] │ thick-t<ail>ed opposum
[39] │ mongol<ian g>erbil
[42] │ h<ous>e m<ous>e
[44] │ r<ound-t><ail>ed muskrat
... and 18 more
```
Remarquez que dans plusieurs instances, notre patron a été trouvé à plusieurs reprises.
Remarquez aussi que notre définition de "consonne" n'est pas tout à fait juste.
Comme les espaces ne sont pas des voyelles, ils sont aussi capturés par notre patron
de recherche.

Un autre caractère spécial particulièrement utile est la barre
verticale (|). Ce dernier permet de définir des séquences alternatives (un OU).
Par exemple, pour trouver tous les écureuils et les tamias, on pourrait écrire :

```r
str_view(noms,"squirrel|chipmunk")
```

```
[27] │ western american <chipmunk>
[66] │ <squirrel> monkey
[70] │ arctic ground <squirrel>
[71] │ thirteen-lined ground <squirrel>
[72] │ golden-mantled ground <squirrel>
[76] │ eastern american <chipmunk>
```

Remarquez que notre séquence a aussi détecté le Singe-écureuil. Nous verrons plus 
loin comment remédier à ce problème.

## Fonctions basées sur les regex
Maintenant que nous avons vu la mécanique de base, nous allons faire un petit
survol des fonctions permettant l'utilisation des regex.

Pour bien illustrer ces fonctions, nous allons nous créer un petit tableau
de données contenant les noms des animaux en minuscule (comme nous avons
utilisé dans la précédente section) combiné à une autre colonne d'information
pour illustrer l'application sur des tableaux.


```r
tableau <- tibble(
  noms = noms,
  sommeil = msleep$sleep_total
)
```


L'application la plus pratique sera sans aucun doute de combiner le filter
de dplyr avec la fonction str_detect.


```r
tableau %>% 
  filter(str_detect(noms, "squirrel|chipmunk"))
```

```
# A tibble: 6 × 2
  noms                           sommeil
  <chr>                            <dbl>
1 western american chipmunk         14.9
2 squirrel monkey                    9.6
3 arctic ground squirrel            16.6
4 thirteen-lined ground squirrel    13.8
5 golden-mantled ground squirrel    15.9
6 eastern american chipmunk         15.8
```

Une autre chose que l'on voudra souvent faire est de remplacer le patron
trouvé par autre chose. Par exemple, si finalement les experts décidaient
que tous les tamias et les écureuils s'appelaient désormais des squimunk, on 
pourrait faire ceci : 

```r
tableau %>% 
  mutate(
    noms = str_replace(noms,"squirrel|chipmunk","squimunk")
  ) %>% slice(70:80)
```

```
# A tibble: 11 × 2
   noms                           sommeil
   <chr>                            <dbl>
 1 arctic ground squimunk            16.6
 2 thirteen-lined ground squimunk    13.8
 3 golden-mantled ground squimunk    15.9
 4 musk shrew                        12.8
 5 pig                                9.1
 6 short-nosed echidna                8.6
 7 eastern american squimunk         15.8
 8 brazilian tapir                    4.4
 9 tenrec                            15.6
10 tree shrew                         8.9
11 bottle-nosed dolphin               5.2
```
Remarquez que j'utilise la fonction `slice` pour vous montrer les lignes
où notre remplacement a été fait.

À l'extrême, on pourrait décider de remplacer tous les "e" par une autre lettre : 

```r
tableau %>% 
  mutate(
    noms = str_replace(noms, "e","X")
  )
```

```
# A tibble: 83 × 2
   noms                       sommeil
   <chr>                        <dbl>
 1 chXetah                       12.1
 2 owl monkXy                    17  
 3 mountain bXaver               14.4
 4 grXater short-tailed shrew    14.9
 5 cow                            4  
 6 thrXe-toed sloth              14.4
 7 northXrn fur seal              8.7
 8 vXsper mouse                   7  
 9 dog                           10.1
10 roX deer                       3  
# … with 73 more rows
```

Comme vous le constatez, str_replace ne change que la première instance trouvée.
Pour remplacer toutes les instances, il faut passer par la fonction str_replace_all : 

```r
tableau %>% 
  mutate(
    noms = str_replace_all(noms, "e","X")
  )
```

```
# A tibble: 83 × 2
   noms                       sommeil
   <chr>                        <dbl>
 1 chXXtah                       12.1
 2 owl monkXy                    17  
 3 mountain bXavXr               14.4
 4 grXatXr short-tailXd shrXw    14.9
 5 cow                            4  
 6 thrXX-toXd sloth              14.4
 7 northXrn fur sXal              8.7
 8 vXspXr mousX                   7  
 9 dog                           10.1
10 roX dXXr                       3  
# … with 73 more rows
```

Si on laisse le deuxième argument vide ("") dans les str_replace, on demande essentiellement
à R d'enlever cette séquence. Il peut parfois être plus élégant et lisible dans ces cas de simplement
utiliser la fonction str_remove (ou str_remove_all). On pourrait éliminer tous les e de nos 
données comme ceci : 

```r
tableau %>% 
  mutate(
    noms = str_remove_all(noms, "e")
  )
```

```
# A tibble: 83 × 2
   noms                   sommeil
   <chr>                    <dbl>
 1 chtah                     12.1
 2 owl monky                 17  
 3 mountain bavr             14.4
 4 gratr short-taild shrw    14.9
 5 cow                        4  
 6 thr-tod sloth             14.4
 7 northrn fur sal            8.7
 8 vspr mous                  7  
 9 dog                       10.1
10 ro dr                      3  
# … with 73 more rows
```

Il existe des dizaines d'autres fonctions permettant de travailler avec des regex,
entre autres `str_subset`, `str_which` et `str_count`que je vous encourage fortement 
à explorer par vous-même


## Caractères d'échappement (encore!)
Bon, alors, si j'avais à vous demander d'écrire un regex pour détecter un point (.), 
vous feriez quoi?


```r
texte <- "Première phrase. Deuxième phrase."
str_view(texte,".")
```

```
[1] │ <P><r><e><m><i><è><r><e>< ><p><h><r><a><s><e><.>< ><D><e><u><x><i><è><m><e>< ><p><h><r><a><s><e><.>
```
Évidemment non. Un point est un joker, qui peut remplacer n'importe quel caractère.

Peut-être avec un caractère d'échappement?

```r
str_view(texte,"\.")
```

```
Error: '\.' is an unrecognized escape in character string starting ""\."
```
Ah non, ça ne marche pas parce que, au moment d'écrire la chaîne de caractères,
R remplace les `\`-quelquechose en les encodant, et `\.`, ça ne veut rien dire pour lui.

Alors, oui, il faut utiliser `\\.` pour détecter un simple petit point!

```r
str_view(texte,"\\.")
```

```
[1] │ Première phrase<.> Deuxième phrase<.>
```

Un backslash au niveau de R et un backslash au niveau de l'interprétation du regex.

Maintenant, si on se prépare une chaîne de caractère avec un backslash dedans : 

```r
bs <- "a\\b"
str_view(bs)
```

```
[1] │ a\b
```
Comment on fait pour le retrouver avec un regex?

Eh oui, ça nous prendra 4 backslash pour en trouver un seul.

```r
str_view(bs, "\\\\")
```

```
[1] │ a<\>b
```

Au moment de créer la chaîne de caractères dans R, on en perd 2 à l'encodage, 
puis au niveau du regex, on en perd un dernier!

Si on veut se simplifier un peu la vie, on peut se rappeller que R nous permet
de créer des chaînes de caractères brutes, qui ne passent pas par l'étape d'encodage : 

```r
bs2 <- r"(a\n)"
str_view(bs2, r"(\\)")
```

```
[1] │ a<\>n
```

Ce n'est pas idéal, mais ça élimine au moins un niveau d'abstraction.

## Caractères spéciaux
Tout comme les regex comprennent leur propre syntaxe, ils comprennent aussi
une série de caractères spéciaux qui leur sont propres.

Voyons tout d'abord les caractères d'ancrage. Les regex comprennent deux
caractères d'ancrage soit `^` et `$` désignant respectivement le début et la 
fin d'une chaîne de caractères

On peut par exemple utiliser un ancrage pour trouver tous les noms de mammifères
qui se terminent par squirrel, et ainsi éliminer de nos résultats le singe-écureuil : 

```r
str_view(noms, "squirrel")
```

```
[66] │ <squirrel> monkey
[70] │ arctic ground <squirrel>
[71] │ thirteen-lined ground <squirrel>
[72] │ golden-mantled ground <squirrel>
```
vs.

```r
str_view(noms, "squirrel$")
```

```
[70] │ arctic ground <squirrel>
[71] │ thirteen-lined ground <squirrel>
[72] │ golden-mantled ground <squirrel>
```

Si on combine les deux caractères d'ancrage, on s'assure que la chaîne de caractères
ne contient que le texte demandé. Rien de plus, rien de moins.


```r
str_view(noms,"pig")
```

```
[12] │ guinea <pig>
[74] │ <pig>
```
vs.

```r
str_view(noms, "^pig$")
```

```
[74] │ <pig>
```

Les regex comprennent aussi des caractères spéciaux nous évitant les longues énumérations. On peut par exemple utiliser `\w` pour trouver n'importe quelle lettre ou chiffre.

Ainsi, pour trouver tous les noms d'espèces composés de deux mots, on pourrait
faire ceci : 

```r
str_view(noms,"^\\w+ \\w+$")
```

```
 [2] │ <owl monkey>
 [3] │ <mountain beaver>
 [8] │ <vesper mouse>
[10] │ <roe deer>
[12] │ <guinea pig>
[19] │ <tree hyrax>
[21] │ <asian elephant>
[25] │ <european hedgehog>
[26] │ <patas monkey>
[28] │ <domestic cat>
[31] │ <pilot whale>
[32] │ <gray seal>
[33] │ <gray hyrax>
[35] │ <mongoose lemur>
[36] │ <african elephant>
[39] │ <mongolian gerbil>
[40] │ <golden hamster>
[42] │ <house mouse>
[45] │ <slow loris>
[55] │ <desert hedgehog>
... and 14 more
```

Il existe aussi série d'autres caractères semblables, dont voici un aperçu : 

* `\d` : n'importe quel chiffre
* `\D` : tout sauf un chiffre
* `\s` : n'importe quel caractère d'espacement (espace, saut de ligne, indentation)
* `\S` : tout sauf un espacement
* `\w` : n'importe quelle lettre ou chiffre
* `\W` : tout ce qui n'est pas une lettre ou un chiffre

Au delà des caractères `+`, `?` et `*`, les regex nous permettent aussi un contrôle
plus fin du nombre de répétition d'un patron, à l'aide des accolades. Pour trouver tous les noms commençant par un mots de 3 lettres suivi d'un espace, on pourrait faire ceci :

```r
str_view(noms,"^\\w{3}\\s")
```

```
 [2] │ <owl >monkey
[10] │ <roe >deer
[22] │ <big >brown bat
[83] │ <red >fox
```

Remarquez qu'il existe aussi un caractère spécial permettant de détecter les
frontières entourant un mot : `\b`.

Si on veut trouver tous les noms comprenant un mot d'exactement 3 lettres, on pourrait faire ceci : 

```r
str_view(noms, "\\b\\w{3}\\b")
```

```
 [2] │ <owl> monkey
 [5] │ <cow>
 [7] │ northern <fur> seal
 [9] │ <dog>
[10] │ <roe> deer
[12] │ guinea <pig>
[16] │ african giant pouched <rat>
[22] │ <big> brown <bat>
[28] │ domestic <cat>
[43] │ little brown <bat>
[64] │ laboratory <rat>
[68] │ cotton <rat>
[69] │ mole <rat>
[74] │ <pig>
[82] │ arctic <fox>
[83] │ <red> <fox>
```

Si on ne mentionne qu'un chiffre, les accolades cherchent un nombre exact de 
détections, mais on peut aussi spécifier deux valeurs, qui donneront les bornes
du nombre de détection acceptable.

Par exemple, pour trouver tous les noms d'animaux comprenant un mot de 3 à 5 lettres,
on écrirait ceci : 

```r
str_view(noms, "\\b\\w{3,5}\\b")
```

```
 [2] │ <owl> monkey
 [4] │ greater <short>-tailed <shrew>
 [5] │ <cow>
 [6] │ <three>-<toed> <sloth>
 [7] │ northern <fur> <seal>
 [8] │ vesper <mouse>
 [9] │ <dog>
[10] │ <roe> <deer>
[11] │ <goat>
[12] │ guinea <pig>
[15] │ <star>-<nosed> <mole>
[16] │ african <giant> pouched <rat>
[17] │ lesser <short>-tailed <shrew>
[18] │ <long>-<nosed> armadillo
[19] │ <tree> <hyrax>
[20] │ <north> american opossum
[21] │ <asian> elephant
[22] │ <big> <brown> <bat>
[23] │ <horse>
[26] │ <patas> monkey
... and 37 more
```

## Priorité d'opération

Tout comme en mathématiques, l'évaluation d'un regex ne s'effectue pas nécessairement de gauche à droite. Il existe un ordre de priorité entre les opérations.

En règle générale, les caractères contrôlant le nombre de répétitions ont préséance
sur ceux définissant des alternatives.

Par exemple `ab+` sera interprété comme `a(b+)`. `^a|b$` sera interprété comme `(^a)|(b$)`, etc.

Contrairement à l'algèbre, ces priorités sont très difficiles à retenir, et le plus
simple est probablement d'utiliser autant de parenthèses que nécessaire pour
clarifier le patron recherché.

## Regroupements et réutilisation
Outre la clarification des priorités, les parenthèses ont une autre utilisation
particulière dans les regex : elles créent des groupes qui peuvent être réutilisés. Chacun des groupes définis par les parenthèses est numéroté automatiquement par R. Ces numéros
peuvent ensuite être utilisés ailleurs dans le regex. Le premier groupe
sera nommé `\1`, le deuxième `\2`, etc.

On peut par exemple trouver tous les animaux dont le nom comporte une double lettre, comme ceci : 

```r
str_view(noms,"(\\w)\\1")
```

```
 [1] │ ch<ee>tah
 [6] │ thr<ee>-toed sloth
[10] │ roe d<ee>r
[14] │ chinchi<ll>a
[17] │ le<ss>er short-tailed shrew
[18] │ long-nosed armadi<ll>o
[19] │ tr<ee> hyrax
[20] │ north american opo<ss>um
[30] │ gira<ff>e
[35] │ mong<oo>se lemur
[37] │ thick-tailed o<pp>osum
[43] │ li<tt>le brown bat
[47] │ northern gra<ss>ho<pp>er mouse
[48] │ ra<bb>it
[49] │ sh<ee>p
[50] │ chimpanz<ee>
[54] │ bab<oo>n
[56] │ po<tt>o
[57] │ d<ee>r mouse
[60] │ co<mm>on porpoise
... and 9 more
```
Le `\w` attrape une lettre, les parenthèses créent un groupe (ici le numéro 1),
et ensuite un réutilise ce groupe pour créer le doublon.

Par le même principe, on peut aussi trouver tous les noms qui commencent et 
finissent par la même lettre : 

```r
str_view(noms,"^(\\w).*\\1$")
```

```
[10] │ <roe deer>
[12] │ <guinea pig>
[45] │ <slow loris>
[67] │ <eastern american mole>
```

La réutilisation de patrons est aussi applicable avec la fonction `str_replace`.

Elle peut permettre par exemple d'inverser les deux premiers mots de chaque nom : 

```r
str_replace(noms,"^(\\w+)\\s(\\w+)(.*)", "\\2 \\1\\3")
```

```
 [1] "cheetah"                        "monkey owl"                    
 [3] "beaver mountain"                "short greater-tailed shrew"    
 [5] "cow"                            "three-toed sloth"              
 [7] "fur northern seal"              "mouse vesper"                  
 [9] "dog"                            "deer roe"                      
[11] "goat"                           "pig guinea"                    
[13] "grivet"                         "chinchilla"                    
[15] "star-nosed mole"                "giant african pouched rat"     
[17] "short lesser-tailed shrew"      "long-nosed armadillo"          
[19] "hyrax tree"                     "american north opossum"        
[21] "elephant asian"                 "brown big bat"                 
[23] "horse"                          "donkey"                        
[25] "hedgehog european"              "monkey patas"                  
[27] "american western chipmunk"      "cat domestic"                  
[29] "galago"                         "giraffe"                       
[31] "whale pilot"                    "seal gray"                     
[33] "hyrax gray"                     "human"                         
[35] "lemur mongoose"                 "elephant african"              
[37] "thick-tailed opposum"           "macaque"                       
[39] "gerbil mongolian"               "hamster golden"                
[41] "vole "                          "mouse house"                   
[43] "brown little bat"               "round-tailed muskrat"          
[45] "loris slow"                     "degu"                          
[47] "grasshopper northern mouse"     "rabbit"                        
[49] "sheep"                          "chimpanzee"                    
[51] "tiger"                          "jaguar"                        
[53] "lion"                           "baboon"                        
[55] "hedgehog desert"                "potto"                         
[57] "mouse deer"                     "phalanger"                     
[59] "seal caspian"                   "porpoise common"               
[61] "potoroo"                        "armadillo giant"               
[63] "hyrax rock"                     "rat laboratory"                
[65] "striped african mouse"          "monkey squirrel"               
[67] "american eastern mole"          "rat cotton"                    
[69] "rat mole"                       "ground arctic squirrel"        
[71] "thirteen-lined ground squirrel" "golden-mantled ground squirrel"
[73] "shrew musk"                     "pig"                           
[75] "short-nosed echidna"            "american eastern chipmunk"     
[77] "tapir brazilian"                "tenrec"                        
[79] "shrew tree"                     "bottle-nosed dolphin"          
[81] "genet"                          "fox arctic"                    
[83] "fox red"                       
```
Nous avons ici 3 duos de parenthèses, donc 3 groupes. Le premier attrape le
premier mot (`\w+`), le deuxième le second mot (encore `\w+`) et le dernier
attrape tout le reste (`.*`). Ensuite, on reconstruit une chaîne de caractères,
mais en plaçant le deuxième groupe (`\2`) avant le premier (`\1`).

# Mise en garde
Comme dit si bien Spider-man : À grand pouvoir correspond grande responsabilité.

C'est particulièrement vrai lorsque l'on parle de regex. Vaut mieux y aller avec modération. Il peut parfois être plus lisible pour votre "vous" futur de séparer
ce que vous avez à faire en quelques opérations simples et lisibles, plutôt que
d'essayer de tout faire dans un regex.

Je vous présente en conclusion un regex classique, utilisé dans une librairie
du langage de programmation Perl pour valider si une adresse de courriel est 
valide ou non (https://metacpan.org/release/RJBS/Email-Valid-1.200/source/lib/Email/Valid.pm) : 

```perl
[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\
xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xf
f\n\015()]*)*\)[\040\t]*)*(?:(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\x
ff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015
"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\
xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80
-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*
)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\
\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\
x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x8
0-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n
\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x
80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^
\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040
\t]*)*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([
^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\
\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\
x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-
\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()
]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\
x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\04
0\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\
n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\
015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?!
[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\
]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\
x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\01
5()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*|(?:[^(\040)<>@,;:".
\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]
)|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^
()<>@,;:".\\\[\]\x80-\xff\000-\010\012-\037]*(?:(?:\([^\\\x80-\xff\n\0
15()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][
^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)|"[^\\\x80-\xff\
n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^()<>@,;:".\\\[\]\
x80-\xff\000-\010\012-\037]*)*<[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?
:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-
\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:@[\040\t]*
(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015
()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()
]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\0
40)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\
[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\
xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*
)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80
-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x
80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t
]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\
\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])
*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x
80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80
-\xff\n\015()]*)*\)[\040\t]*)*)*(?:,[\040\t]*(?:\([^\\\x80-\xff\n\015(
)]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\
\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*@[\040\t
]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\0
15()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015
()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(
\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|
\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80
-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()
]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x
80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^
\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040
\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".
\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff
])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\
\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x
80-\xff\n\015()]*)*\)[\040\t]*)*)*)*:[\040\t]*(?:\([^\\\x80-\xff\n\015
()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\
\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)?(?:[^
(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-
\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\
n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|
\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))
[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff
\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\x
ff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(
?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\
000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\
xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\x
ff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)
*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*@[\040\t]*(?:\([^\\\x80-\x
ff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-
\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)
*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\
]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]
)[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-
\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\x
ff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(
?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80
-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<
>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x8
0-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:
\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]
*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)
*\)[\040\t]*)*)*>)
```
# Références

La plupart du matériel de cet atelier est fortement inspiré des chapitres en construction de la prochaine édition de R for Data Science de Hadley Wickham, disponibles en ligne ici :

<https://r4ds.hadley.nz/strings.html>

<https://r4ds.hadley.nz/regexps.html>
