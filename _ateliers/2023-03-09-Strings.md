---
layout: default
category: Programmation
thumbnail: stringr.png
title: "La manipulation de texte dans R"
author: "Charles Martin"
date: "2023-03-09"
lang: fr
output:
  html_document:
    highlight: haddock
    keep_md: yes
    theme: readable
    toc: yes
    self_contained: true
    toc_float: true	
en_url: /en/workshops/Strings
---

# La manipulation de texte dans R
{:.no_toc}

## Charles Martin
{:.no_toc}

## Mars 2023
{:.no_toc}

* TOC
{:toc}


# Librairies nÃ©cessaires

Cet atelier nÃ©cessitera des versions rÃ©centes des librairies readr (version 2.1 minimum), stringr (version 1.5 minimum), tidyr (version 1.3 minimum) et dplyr. Vous pouvez soit les activer individuellement, ou activer la mÃ©ta-librairie tidyverse :


```r
library(tidyverse)
```

```
â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.2 â”€â”€
âœ” ggplot2 3.4.0      âœ” purrr   1.0.1 
âœ” tibble  3.1.8      âœ” dplyr   1.0.10
âœ” tidyr   1.3.0      âœ” stringr 1.5.0 
âœ” readr   2.1.2      âœ” forcats 0.5.2 
â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
âœ– dplyr::filter() masks stats::filter()
âœ– dplyr::lag()    masks stats::lag()
```

# Comment se construit le texte dans R

Avant de se lancer dans la manipulation de texte comme tel, il importe de bien comprendre la nature du texte dans R et comment le construire.

## Comment le texte est encodÃ© dans l'ordinateur

Dans la mÃ©moire de R, dans les fichiers CSV, etc. le texte est conservÃ© dans une sÃ©rie de codes hexadÃ©cimaux On peut d'ailleurs voir les codes correspondant avec la fonction `charToRaw` :


```r
charToRaw("Charles")
```

```
[1] 43 68 61 72 6c 65 73
```

Le "C" est encodÃ© avec 43, le "h" par 68, etc.

Si on fait la mathÃ©matique de la chose, on rÃ©alise rapidement que ce systÃ¨me ne peut reprÃ©senter que 16\*16 = 256 symboles. Cela fonctionnait bien Ã  une Ã©poque oÃ¹ les amÃ©ricains avaient la main mise sur l'informatique, mais ne fonctionne pas du tout pour conserver du texte provenant de n'importe quelle langue dans le monde.

Dans les annÃ©es 1980-1990, une sÃ©rie de standards ont Ã©tÃ© dÃ©veloppÃ©s pour permettre l'encodage de caractÃ¨res autres que l'anglais. Entre autres, le ISO-8859-1 (Latin1) permettait l'encodage de la plupart des caractÃ¨res utilisÃ©s en Europe de l'ouest, Latin2 en Europe de l'est, etc.

Aujourd'hui, il existe un standard international, nommÃ© UTF-8, qui permet d'encoder l'ensemble des caractÃ¨res imaginables, incluant mÃªme les Emoji.

La plupart des logiciels modernes utilisent cet encodage et l'utilisation d'accents dans les fichiers n'est plus un problÃ¨me. Cependant, certaines applications plus vieilles et certains fichiers produits il y a un certain temps d'adhÃ¨rent pas nÃ©cessairement Ã  cette convention.

C'est pour cette raison que parfois, en chargeant un fichier CSV, vous verrez une sÃ©rie de caractÃ¨res bizarres dans vos donnÃ©es :


```r
read_csv("Latin1.csv")
```

```
Rows: 2 Columns: 3
â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Delimiter: ","
chr (1): Col3
dbl (2): Col1, Col2

â„¹ Use `spec()` to retrieve the full column specification for this data.
â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```
# A tibble: 2 Ã— 3
   Col1  Col2 Col3            
  <dbl> <dbl> <chr>           
1     1     2 "All\xf4"       
2     3     4 "\xc0 la place?"
```
Avec essai/erreur, on peut tenter de *deviner* le bon encodage et le spÃ©cifier au moment du chargement :

```r
read_csv("Latin1.csv",locale = locale(encoding = "Windows-1252"))
```

```
Rows: 2 Columns: 3
â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Delimiter: ","
chr (1): Col3
dbl (2): Col1, Col2

â„¹ Use `spec()` to retrieve the full column specification for this data.
â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```
# A tibble: 2 Ã— 3
   Col1  Col2 Col3       
  <dbl> <dbl> <chr>      
1     1     2 AllÃ´       
2     3     4 Ã€ la place?
```

```r
read_csv("Latin1.csv",locale = locale(encoding = "Latin1"))
```

```
Rows: 2 Columns: 3
â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Delimiter: ","
chr (1): Col3
dbl (2): Col1, Col2

â„¹ Use `spec()` to retrieve the full column specification for this data.
â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```
# A tibble: 2 Ã— 3
   Col1  Col2 Col3       
  <dbl> <dbl> <chr>      
1     1     2 AllÃ´       
2     3     4 Ã€ la place?
```

Habituellement, si vous essayez Latin1, UTF-8 ou Windows-1252, vous Ãªtes presque certaines d'Ãªtre tombÃ©e sur le bon.

Les versions rÃ©centes de la librairie readr sont maintenant Ã©quipÃ©es d'une fonction vous permettant de laisser l'ordinateur faire ce sale boulot pour vous : 

```r
guess_encoding("Latin1.csv")
```

```
# A tibble: 2 Ã— 2
  encoding   confidence
  <chr>           <dbl>
1 ISO-8859-1       0.62
2 ISO-8859-2       0.41
```

## CrÃ©ation manuelle de texte
Maintenant, comment peut-on faire pour crÃ©er du texte dans R?

La faÃ§on la plus simple est de crÃ©er un objet chaÃ®ne de caractÃ¨res, comme ceci : 

```r
chaine1 <- "Il faut l'essayer"
chaine2 <- 'Voici un autre "essai"'
```

Remarquez que l'on peut utiliser le guillemet simple ou double pour dÃ©marrer et
terminer notre sÃ©quence.

En gÃ©nÃ©ral, il est recommandÃ© d'utiliser le guillemet double, sauf si votre chaÃ®ne
de caractÃ¨res en contient plusieurs.

On peut aussi inclure un guillemet double dans une sÃ©quence dÃ©marrÃ©e par un guillemet
double, en utilisant un caractÃ¨re Ã©chappement (*escape character*), soit le 
backslash (`\`) :

```r
chaine3 <- "Je contient un \" et Ã§a fonctionne tout de mÃªme"
```

Par consÃ©quent, si vous voulez produire un backslash dans une chaÃ®ne de caractÃ¨res, 
vous devrez le prÃ©cÃ©der d'un autre backslash : 

```r
backslash <- "\\"
```

Remarquez que, si vous envoyez une de ces chaÃ®nes de caractÃ¨re Ã  la console, 
on verra le caractÃ¨re d'Ã©chappement : 

```r
chaine3
```

```
[1] "Je contient un \" et Ã§a fonctionne tout de mÃªme"
```

```r
backslash
```

```
[1] "\\"
```
Cela survient parce que, par dÃ©faut, la fonction print de R (appelÃ©e implicitement) nous fournit non pas ce qu'il voit comme texte, mais ce que l'on devrait taper pour le reconstruire.

Si on veut voir la vraie reprÃ©sentation du texte (comme on la verra dans les graphiques, etc.), on peut utiliser la fonction
`str_view`. Comparez ces deux sorties : 

```r
print(c(chaine1, chaine2, chaine3))
```

```
[1] "Il faut l'essayer"                              
[2] "Voici un autre \"essai\""                       
[3] "Je contient un \" et Ã§a fonctionne tout de mÃªme"
```

```r
str_view(c(chaine1, chaine2, chaine3))
```

```
[1] â”‚ Il faut l'essayer
[2] â”‚ Voici un autre "essai"
[3] â”‚ Je contient un " et Ã§a fonctionne tout de mÃªme
```

Il est aussi possible de crÃ©er des chaÃ®nes de caractÃ¨res que l'on dit "brutes",
pour lesquelles, au moment de leur crÃ©ation, R n'essaie pas de gÃ©rer les 
caractÃ¨res d'Ã©chappement. Pour cela, il faut dÃ©buter notre chaÃ®ne par
`r"(` et la terminer par `)"`

```r
complexe <- r"(L'apostrophe, le \ et mÃªme les "guillemets" ne posent plus de problÃ¨mes)"
str_view(complexe)
```

```
[1] â”‚ L'apostrophe, le \ et mÃªme les "guillemets" ne posent plus de problÃ¨mes
```
On peut remplacer au besoin `r"()"` par `r"[]"`, `r"{}"`, etc.

## CaractÃ¨res d'Ã©chappement

Outre `\"` `\'` et `\\`, il existe une sÃ©rie d'autres caractÃ¨res spÃ©ciaux lorsque l'on construit du texte dans R.

Entre autres : 

* `\n` ajoute un saut de ligne
* `\t` ajoute une indentation
* et `\u` et `\U` nous permettent d'insÃ©rer n'importe quel caractÃ¨re unicode


```r
str_view(c(
  "Saut\nde\nligne",
  "avec\tindentation",
  "\u00b5 mu",
  "\U0001f4a9 (sans commentaires)"
))
```

```
[1] â”‚ Saut
    â”‚ de
    â”‚ ligne
[2] â”‚ avec{\t}indentation
[3] â”‚ Âµ mu
[4] â”‚ ðŸ’© (sans commentaires)
```

Vous pouvez taper `?'"'` Ã  la console pour plus de dÃ©tails sur les possibilitÃ©s des caractÃ¨res d'Ã©chappement.

## CrÃ©ation de texte par programmation
Pour crÃ©er et combiner du texte par programmation, il existe trois fonctions dans le tidyverse, soit  `str_c` et `str_glue` pour travailler directement sur les objets (mutate, etc.) et `str_flatten` pour les cas oÃ¹ on tente de rÃ©sumer du texte.

La fonction `str_c` fonctionne comme la fonction `c`, mais pour coller des morceaux de texte dans une chaÃ®ne, plutÃ´t que coller des nombres dans un vecteur.

```r
str_c("a","b","c")
```

```
[1] "abc"
```

```r
str_c("Salut ",c("Charles","Vincent"))
```

```
[1] "Salut Charles" "Salut Vincent"
```
Son fonctionnement est trÃ¨s similaire Ã  la fonction `paste0`, mais sa gestion des valeurs manquantes et des vecteurs de diffÃ©rentes longueurs (voir exemple prÃ©cÃ©dent) est plus constante avec l'ensemble des autres fonctions du tidyverse.

Chaque Ã©lÃ©ment passÃ© Ã  str_c peut Ã©videmment Ãªtre un objet contenant du texte, plutÃ´t que le texte directement :

```r
nom <- "Charles"
moment <- "aujourd'hui"
str_c("Bonjour ", nom, "! Comment allez-vous ", moment, "?")
```

```
[1] "Bonjour Charles! Comment allez-vous aujourd'hui?"
```
Bien que pratique, cette approche peut devenir fastidieuse si on a plusieurs morceaux de texte Ã  rassembler et qu'il faut chaque fois fermer le guillemet, ajouter la virgule, ouvrir le guillemet, etc. sans rien oublier.

C'est lÃ  oÃ¹ entre en scÃ¨ne la fonction `str_glue` : 

```r
str_glue("Bonjour {nom}, comment allez-vous {moment}?")
```

```
Bonjour Charles, comment allez-vous aujourd'hui?
```

R remplacera automatiquement chaque mot entourÃ© dâ€™accolades par le contenu de la variable du mÃªme nom.


```r
noms <- c("Pierre","Paul","Jacques")
str_glue("Bonjour {noms}, comment allez-vous {moment}?")
```

```
Bonjour Pierre, comment allez-vous aujourd'hui?
Bonjour Paul, comment allez-vous aujourd'hui?
Bonjour Jacques, comment allez-vous aujourd'hui?
```

Comme vous le constatez peut-Ãªtre, `str_c` et `str_glue` fonctionneront trÃ¨s bien dans des contextes comme un mutate oÃ» la fonction doit produire une sÃ©rie de chaÃ®nes de caractÃ¨res en rÃ©ponse Ã  un vecteur.

Si notre opÃ©ration doit impÃ©rativement retourner une seule chaÃ®ne, alors il faut utiliser la fonction `str_flatten` :

```r
str_flatten(noms, ", ")
```

```
[1] "Pierre, Paul, Jacques"
```
On peut aussi contrÃ´ler le dernier sÃ©parateur pour faire de belles Ã©numÃ©rations : 

```r
str_flatten(noms,", ",last = " et ")
```

```
[1] "Pierre, Paul et Jacques"
```


```r
habitats <- tribble(
  ~Espece,~Habitat,
  "A","dÃ©sert",
  "A","forÃªt",
  "B", "forÃªt",
  "A", "tundra"
)
habitats %>% 
  group_by(Espece) %>% 
  summarize(
    Nombre = n(),
    Liste = str_flatten(Habitat,", ")
  )
```

```
# A tibble: 2 Ã— 3
  Espece Nombre Liste                
  <chr>   <int> <chr>                
1 A           3 dÃ©sert, forÃªt, tundra
2 B           1 forÃªt                
```

# L'extraction de texte

Une autre tÃ¢che extrÃªmement commune qui se produit dans nos analyses R est 
de devoir extraire de l'information textuelle Ã  partir de variables dÃ©jÃ 
existantes.

La librairie tidyr fournit une sÃ©rie de fonctions pensÃ©es expressÃ©ment pour 
ce genre de situation : la famille `separate_`, qui comprend 4 fonctions, soit : 

* `separate_longer_delim`
* `separate_longer_position`
* `separate_wider_delim`
* `separate_wider_position`

Dans tous les cas, les fonctions vont analyser le texte contenu dans une variable,
et le sÃ©parer en morceaux. Soit en vous crÃ©ant une observation par morceau (_longer),
ou soit en crÃ©ant une colonne par morceau (_wider).

Le dÃ©coupage des morceaux peut Ãªtre basÃ© soit sur un sÃ©parateur (_delim), ou soit
basÃ© sur la position du texte (_position)

Ces fonctions sont trÃ¨s pratiques, par exemple, quand vous avez encodÃ© de l'information
dans le nom des sites de votre expÃ©rience : 

```r
experience_a <- tibble(
  nom_site = c("CT01","CT02","CT03","TR01","TR02","TR03")
)
experience_a
```

```
# A tibble: 6 Ã— 1
  nom_site
  <chr>   
1 CT01    
2 CT02    
3 CT03    
4 TR01    
5 TR02    
6 TR03    
```

Il suffit de fournir Ã  la fonction le nombre de caractÃ¨res de chacun des 
morceaux, avec le nom que doit contenir cette colonne au final.


```r
experience_a %>% 
  separate_wider_position(nom_site,c(traitement = 2, no_replicat = 2) )
```

```
# A tibble: 6 Ã— 2
  traitement no_replicat
  <chr>      <chr>      
1 CT         01         
2 CT         02         
3 CT         03         
4 TR         01         
5 TR         02         
6 TR         03         
```

Si nos informations avaient plutÃ´t Ã©tÃ© sur ce format : 

```r
experience_b <- tibble(
  nom_site = c("CT-1","CT-10","R-1","R-100")
)
experience_b
```

```
# A tibble: 4 Ã— 1
  nom_site
  <chr>   
1 CT-1    
2 CT-10   
3 R-1     
4 R-100   
```
on aurait pu les extraire en se basant sur la prÃ©sence du sÃ©parateur, comme ceci : 

```r
experience_b %>% 
  separate_wider_delim(nom_site,delim = "-",names = c("traitement","no_replicat"))
```

```
# A tibble: 4 Ã— 2
  traitement no_replicat
  <chr>      <chr>      
1 CT         1          
2 CT         10         
3 R          1          
4 R          100        
```

Enfin, il pourrait arriver que l'information de plusieurs observations soit 
encodÃ©e dans une mÃªme cellule : 

```r
experience_c <- tibble(
  site = c("A","B"),
  resultats_visites = c("0,0,1","1,0,1"),
  latitude = c(46,47),
  longitude = c(-72,-72.5)
)
experience_c
```

```
# A tibble: 2 Ã— 4
  site  resultats_visites latitude longitude
  <chr> <chr>                <dbl>     <dbl>
1 A     0,0,1                   46     -72  
2 B     1,0,1                   47     -72.5
```
On peut alors utiliser une fonction _longer pour recrÃ©er chacune des observation : 

```r
experience_c %>% 
  separate_longer_delim(resultats_visites, delim = ",")
```

```
# A tibble: 6 Ã— 4
  site  resultats_visites latitude longitude
  <chr> <chr>                <dbl>     <dbl>
1 A     0                       46     -72  
2 A     0                       46     -72  
3 A     1                       46     -72  
4 B     1                       47     -72.5
5 B     0                       47     -72.5
6 B     1                       47     -72.5
```

Pour des opÃ©rations plus simples, vous pouvez aussi aller chercher directement
des bouts de texte avec la fonction str_sub.

Elle permet d'utiliser des numÃ©ros de position positifs quand on veut calculer Ã 
partir du dÃ©but, et des numÃ©ros de position nÃ©gatifs quand on veut calculer Ã  partir
de la fin : 

```r
str_sub("LongTexte",5,9)
```

```
[1] "Texte"
```

```r
str_sub("LongTexte",-5, -1)
```

```
[1] "Texte"
```

# Les expressions rÃ©guliÃ¨res (regex)

Maintenant que nous avons vu la plupart des fonctions permettant de traiter le 
texte par programmation, nous allons nous attaquer Ã  une deuxiÃ¨me faÃ§on soit 
les expression rÃ©guliÃ¨res (*regular expressions*), communÃ©ment appelÃ©es par
leur acronyme anglais : regex!

Les regex sont des sÃ©quences de caractÃ¨res permettant de dÃ©finir un patron
de recherche Ã  utiliser, de faÃ§on hyper efficace.

Le prix Ã  payer pour cette efficacitÃ© est que les regex sont parfois difficiles Ã 
lire et Ã  dÃ©boguer. Certains parlent parfois de magie noire, Ã  cause de leur
cÃ´tÃ© un peu obscur et imprÃ©visible. Mais bien maÃ®trisÃ©s, ils sont extrÃªmement
puissants.

## Exploration avec str_view
Pour faciliter notre apprentissage des regex, nous allons utiliser une fonction
qui permet de les tester visuellement, soit la fonction `str_view`.

Pour illustrer nos exemples, nous utiliserons la colonne name de la base de donnÃ©es
msleep, qui est founie avec la librairie ggplot2

```r
head(msleep$name)
```

```
[1] "Cheetah"                    "Owl monkey"                
[3] "Mountain beaver"            "Greater short-tailed shrew"
[5] "Cow"                        "Three-toed sloth"          
```

Pour se simplifier la vie, nous allons par contre extraire tous les noms
dans un nouveau vecteur, que nous allons aussi convertir en minuscules

```r
noms <- msleep$name %>% str_to_lower()
head(noms)
```

```
[1] "cheetah"                    "owl monkey"                
[3] "mountain beaver"            "greater short-tailed shrew"
[5] "cow"                        "three-toed sloth"          
```


Ã€ la base, un regex est une sÃ©quence de caractÃ¨res Ã  chercher : 

```r
str_view(noms,"shrew")
```

```
 [4] â”‚ greater short-tailed <shrew>
[17] â”‚ lesser short-tailed <shrew>
[73] â”‚ musk <shrew>
[79] â”‚ tree <shrew>
```

La fonction str_view nous montre tous les Ã©lÃ©ments du vecteur de noms qui contenaient
la sÃ©quence recherchÃ©e ("shrew"). Remarquez que dans les sorties, la partie qui 
correspondait Ã  notre regex a Ã©tÃ© entourÃ©e de `< >` et, si vous regardez les sorties
dans la console, elle sera aussi d'une autre couleur.

Remarquez que les regex sont sensibles Ã  la casse (aux diffÃ©rences majuscules/minuscules).
Le patron "SHREW" ne retourne par exemple aucun rÃ©sultat : 

```r
str_view(noms, "SHREW")
```

## La construction de sÃ©quences de recherche
Outre les sÃ©quences de caractÃ¨res recherchÃ©s, un regex peut aussi contenir des
mÃ©ta-caractÃ¨res permettant de contrÃ´ler plus prÃ©cisÃ©ment la recherche.

Le premier que nous verrons est le `.` qui, comme un joker, permet de remplacer
n'importe quel caractÃ¨re.

On peut l'utiliser par exemple pour trouver tous les noms contenant le mot gris
en anglais, peut importe qu'il soit Ã©crit gray ou grey : 

```r
str_view(noms,"gr.y")
```

```
[32] â”‚ <gray> seal
[33] â”‚ <gray> hyrax
```

Il existe ensuite trois mÃ©ta-caractÃ¨res permettant de choisir le nombre de fois
que chacun des patrons recherchÃ© doit survenir: 

* `+` : 1 fois ou plus (obligatoire)
* `?` : 0 ou 1 fois (optionnel)
* `*` : 0 ou plus (optionnel avec possible rÃ©pÃ©tition)

Par exemple, tous les noms contenant un a suivi d'au moins un s

```r
str_view(noms, "as+")
```

```
[21] â”‚ <as>ian elephant
[26] â”‚ pat<as> monkey
[47] â”‚ northern gr<ass>hopper mouse
[59] â”‚ c<as>pian seal
[67] â”‚ e<as>tern american mole
[76] â”‚ e<as>tern american chipmunk
```
Remarquez dans ce cas que notre patron contient le 2e s dans "grass hopper"

Avec le ?, la prÃ©sence du caractÃ¨re devient optionnelle. On peut attraper
par exemple tous les noms contenant ham ou am, comme ceci : 

```r
str_view(noms,"h?am")
```

```
[20] â”‚ north <am>erican opossum
[27] â”‚ western <am>erican chipmunk
[40] â”‚ golden <ham>ster
[67] â”‚ eastern <am>erican mole
[76] â”‚ eastern <am>erican chipmunk
```

Enfin, avec l'astÃ©risque, on peut rendre un patron optionnel, et ce, mÃªme si il se rÃ©pÃ¨te.
On peut par exemple chercher tous les noms contenant "oo", ou avec n'importe quel nombre de p
entre les deux o, comme ceci : 

```r
str_view(noms,"op*o")
```

```
[20] â”‚ north american <opo>ssum
[35] â”‚ mong<oo>se lemur
[37] â”‚ thick-tailed <oppo>sum
[54] â”‚ bab<oo>n
[61] â”‚ potor<oo>
```

Les parenthÃ¨ses carrÃ©es, quant Ã  elles, permettent de dÃ©finir une sÃ©rie d'alternatives
pouvait Ãªtre cherchÃ©es. On peut par exemple trouver tous les rats, les chats et les chauve-souris
comme ceci :

```r
str_view(noms,"[cbr]at")
```

```
[16] â”‚ african giant pouched <rat>
[22] â”‚ big brown <bat>
[28] â”‚ domestic <cat>
[43] â”‚ little brown <bat>
[44] â”‚ round-tailed musk<rat>
[64] â”‚ labo<rat>ory <rat>
[68] â”‚ cotton <rat>
[69] â”‚ mole <rat>
```

L'accent circonflexe permet d'inverser la condition de la parenthÃ¨se carrÃ©e. 
On pourrait par exemple chercher toutes les fois oÃ¹ "at" apparaÃ®t, mais que ce
n'est pas un chat ou un rat : 

```r
str_view(noms,"[^cr]at")
```

```
 [4] â”‚ gr<eat>er short-tailed shrew
[11] â”‚ g<oat>
[22] â”‚ big brown <bat>
[26] â”‚ <pat>as monkey
[43] â”‚ little brown <bat>
```

On peut aussi combiner les parenthÃ¨ses carrÃ©es et les mÃ©ta-caractÃ¨res dÃ©finissant les 
nombres d'apparitions. On pourrait par exemple chercher tous les mots contenant deux
voyelles suivies d'une ou plusieurs consonnes, comme ceci : 

```r
str_view(noms,"[aeiou][aeiou][^aeiou]+")
```

```
 [1] â”‚ ch<eet>ah
 [3] â”‚ m<ount><ain b><eav>er
 [4] â”‚ gr<eat>er short-t<ail>ed shrew
 [6] â”‚ thr<ee-t><oed sl>oth
 [7] â”‚ northern fur s<eal>
 [8] â”‚ vesper m<ous>e
[10] â”‚ r<oe d><eer>
[11] â”‚ g<oat>
[12] â”‚ g<uin><ea p>ig
[16] â”‚ african g<iant p><ouch>ed rat
[17] â”‚ lesser short-t<ail>ed shrew
[19] â”‚ tr<ee hyr>ax
[21] â”‚ as<ian >elephant
[25] â”‚ <eur>op<ean h>edgehog
[32] â”‚ gray s<eal>
[35] â”‚ mong<oos>e lemur
[37] â”‚ thick-t<ail>ed opposum
[39] â”‚ mongol<ian g>erbil
[42] â”‚ h<ous>e m<ous>e
[44] â”‚ r<ound-t><ail>ed muskrat
... and 18 more
```
Remarquez que dans plusieurs instances, notre patron a Ã©tÃ© trouvÃ© Ã  plusieurs reprises.
Remarquez aussi que notre dÃ©finition de "consonne" n'est pas tout Ã  fait juste.
Comme les espaces ne sont pas des voyelles, ils sont aussi capturÃ©s par notre patron
de recherche.

Un autre caractÃ¨re spÃ©cial particuliÃ¨rement utile est la barre
verticale (|). Ce dernier permet de dÃ©finir des sÃ©quences alternatives (un OU).
Par exemple, pour trouver tous les Ã©cureuils et les tamias, on pourrait Ã©crire :

```r
str_view(noms,"squirrel|chipmunk")
```

```
[27] â”‚ western american <chipmunk>
[66] â”‚ <squirrel> monkey
[70] â”‚ arctic ground <squirrel>
[71] â”‚ thirteen-lined ground <squirrel>
[72] â”‚ golden-mantled ground <squirrel>
[76] â”‚ eastern american <chipmunk>
```

Remarquez que notre sÃ©quence a aussi dÃ©tectÃ© le Singe-Ã©cureuil. Nous verrons plus 
loin comment remÃ©dier Ã  ce problÃ¨me.

## Fonctions basÃ©es sur les regex
Maintenant que nous avons vu la mÃ©canique de base, nous allons faire un petit
survol des fonctions permettant l'utilisation des regex.

Pour bien illustrer ces fonctions, nous allons nous crÃ©er un petit tableau
de donnÃ©es contenant les noms des animaux en minuscule (comme nous avons
utilisÃ© dans la prÃ©cÃ©dente section) combinÃ© Ã  une autre colonne d'information
pour illustrer l'application sur des tableaux.


```r
tableau <- tibble(
  noms = noms,
  sommeil = msleep$sleep_total
)
```


L'application la plus pratique sera sans aucun doute de combiner le filter
de dplyr avec la fonction str_detect.


```r
tableau %>% 
  filter(str_detect(noms, "squirrel|chipmunk"))
```

```
# A tibble: 6 Ã— 2
  noms                           sommeil
  <chr>                            <dbl>
1 western american chipmunk         14.9
2 squirrel monkey                    9.6
3 arctic ground squirrel            16.6
4 thirteen-lined ground squirrel    13.8
5 golden-mantled ground squirrel    15.9
6 eastern american chipmunk         15.8
```

Une autre chose que l'on voudra souvent faire est de remplacer le patron
trouvÃ© par autre chose. Par exemple, si finalement les experts dÃ©cidaient
que tous les tamias et les Ã©cureuils s'appelaient dÃ©sormais des squimunk, on 
pourrait faire ceci : 

```r
tableau %>% 
  mutate(
    noms = str_replace(noms,"squirrel|chipmunk","squimunk")
  ) %>% slice(70:80)
```

```
# A tibble: 11 Ã— 2
   noms                           sommeil
   <chr>                            <dbl>
 1 arctic ground squimunk            16.6
 2 thirteen-lined ground squimunk    13.8
 3 golden-mantled ground squimunk    15.9
 4 musk shrew                        12.8
 5 pig                                9.1
 6 short-nosed echidna                8.6
 7 eastern american squimunk         15.8
 8 brazilian tapir                    4.4
 9 tenrec                            15.6
10 tree shrew                         8.9
11 bottle-nosed dolphin               5.2
```
Remarquez que j'utilise la fonction `slice` pour vous montrer les lignes
oÃ¹ notre remplacement a Ã©tÃ© fait.

Ã€ l'extrÃªme, on pourrait dÃ©cider de remplacer tous les "e" par une autre lettre : 

```r
tableau %>% 
  mutate(
    noms = str_replace(noms, "e","X")
  )
```

```
# A tibble: 83 Ã— 2
   noms                       sommeil
   <chr>                        <dbl>
 1 chXetah                       12.1
 2 owl monkXy                    17  
 3 mountain bXaver               14.4
 4 grXater short-tailed shrew    14.9
 5 cow                            4  
 6 thrXe-toed sloth              14.4
 7 northXrn fur seal              8.7
 8 vXsper mouse                   7  
 9 dog                           10.1
10 roX deer                       3  
# â€¦ with 73 more rows
```

Comme vous le constatez, str_replace ne change que la premiÃ¨re instance trouvÃ©e.
Pour remplacer toutes les instances, il faut passer par la fonction str_replace_all : 

```r
tableau %>% 
  mutate(
    noms = str_replace_all(noms, "e","X")
  )
```

```
# A tibble: 83 Ã— 2
   noms                       sommeil
   <chr>                        <dbl>
 1 chXXtah                       12.1
 2 owl monkXy                    17  
 3 mountain bXavXr               14.4
 4 grXatXr short-tailXd shrXw    14.9
 5 cow                            4  
 6 thrXX-toXd sloth              14.4
 7 northXrn fur sXal              8.7
 8 vXspXr mousX                   7  
 9 dog                           10.1
10 roX dXXr                       3  
# â€¦ with 73 more rows
```

Si on laisse le deuxiÃ¨me argument vide ("") dans les str_replace, on demande essentiellement
Ã  R d'enlever cette sÃ©quence. Il peut parfois Ãªtre plus Ã©lÃ©gant et lisible dans ces cas de simplement
utiliser la fonction str_remove (ou str_remove_all). On pourrait Ã©liminer tous les e de nos 
donnÃ©es comme ceci : 

```r
tableau %>% 
  mutate(
    noms = str_remove_all(noms, "e")
  )
```

```
# A tibble: 83 Ã— 2
   noms                   sommeil
   <chr>                    <dbl>
 1 chtah                     12.1
 2 owl monky                 17  
 3 mountain bavr             14.4
 4 gratr short-taild shrw    14.9
 5 cow                        4  
 6 thr-tod sloth             14.4
 7 northrn fur sal            8.7
 8 vspr mous                  7  
 9 dog                       10.1
10 ro dr                      3  
# â€¦ with 73 more rows
```

Il existe des dizaines d'autres fonctions permettant de travailler avec des regex,
entre autres `str_subset`, `str_which` et `str_count`que je vous encourage fortement 
Ã  explorer par vous-mÃªme


## CaractÃ¨res d'Ã©chappement (encore!)
Bon, alors, si j'avais Ã  vous demander d'Ã©crire un regex pour dÃ©tecter un point (.), 
vous feriez quoi?


```r
texte <- "PremiÃ¨re phrase. DeuxiÃ¨me phrase."
str_view(texte,".")
```

```
[1] â”‚ <P><r><e><m><i><Ã¨><r><e>< ><p><h><r><a><s><e><.>< ><D><e><u><x><i><Ã¨><m><e>< ><p><h><r><a><s><e><.>
```
Ã‰videmment non. Un point est un joker, qui peut remplacer n'importe quel caractÃ¨re.

Peut-Ãªtre avec un caractÃ¨re d'Ã©chappement?

```r
str_view(texte,"\.")
```

```
Error: '\.' is an unrecognized escape in character string starting ""\."
```
Ah non, Ã§a ne marche pas parce que, au moment d'Ã©crire la chaÃ®ne de caractÃ¨res,
R remplace les `\`-quelquechose en les encodant, et `\.`, Ã§a ne veut rien dire pour lui.

Alors, oui, il faut utiliser `\\.` pour dÃ©tecter un simple petit point!

```r
str_view(texte,"\\.")
```

```
[1] â”‚ PremiÃ¨re phrase<.> DeuxiÃ¨me phrase<.>
```

Un backslash au niveau de R et un backslash au niveau de l'interprÃ©tation du regex.

Maintenant, si on se prÃ©pare une chaÃ®ne de caractÃ¨re avec un backslash dedans : 

```r
bs <- "a\\b"
str_view(bs)
```

```
[1] â”‚ a\b
```
Comment on fait pour le retrouver avec un regex?

Eh oui, Ã§a nous prendra 4 backslash pour en trouver un seul.

```r
str_view(bs, "\\\\")
```

```
[1] â”‚ a<\>b
```

Au moment de crÃ©er la chaÃ®ne de caractÃ¨res dans R, on en perd 2 Ã  l'encodage, 
puis au niveau du regex, on en perd un dernier!

Si on veut se simplifier un peu la vie, on peut se rappeller que R nous permet
de crÃ©er des chaÃ®nes de caractÃ¨res brutes, qui ne passent pas par l'Ã©tape d'encodage : 

```r
bs2 <- r"(a\n)"
str_view(bs2, r"(\\)")
```

```
[1] â”‚ a<\>n
```

Ce n'est pas idÃ©al, mais Ã§a Ã©limine au moins un niveau d'abstraction.

## CaractÃ¨res spÃ©ciaux
Tout comme les regex comprennent leur propre syntaxe, ils comprennent aussi
une sÃ©rie de caractÃ¨res spÃ©ciaux qui leur sont propres.

Voyons tout d'abord les caractÃ¨res d'ancrage. Les regex comprennent deux
caractÃ¨res d'ancrage soit `^` et `$` dÃ©signant respectivement le dÃ©but et la 
fin d'une chaÃ®ne de caractÃ¨res

On peut par exemple utiliser un ancrage pour trouver tous les noms de mammifÃ¨res
qui se terminent par squirrel, et ainsi Ã©liminer de nos rÃ©sultats le singe-Ã©cureuil : 

```r
str_view(noms, "squirrel")
```

```
[66] â”‚ <squirrel> monkey
[70] â”‚ arctic ground <squirrel>
[71] â”‚ thirteen-lined ground <squirrel>
[72] â”‚ golden-mantled ground <squirrel>
```
vs.

```r
str_view(noms, "squirrel$")
```

```
[70] â”‚ arctic ground <squirrel>
[71] â”‚ thirteen-lined ground <squirrel>
[72] â”‚ golden-mantled ground <squirrel>
```

Si on combine les deux caractÃ¨res d'ancrage, on s'assure que la chaÃ®ne de caractÃ¨res
ne contient que le texte demandÃ©. Rien de plus, rien de moins.


```r
str_view(noms,"pig")
```

```
[12] â”‚ guinea <pig>
[74] â”‚ <pig>
```
vs.

```r
str_view(noms, "^pig$")
```

```
[74] â”‚ <pig>
```

Les regex comprennent aussi des caractÃ¨res spÃ©ciaux nous Ã©vitant les longues Ã©numÃ©rations. On peut par exemple utiliser `\w` pour trouver n'importe quelle lettre ou chiffre.

Ainsi, pour trouver tous les noms d'espÃ¨ces composÃ©s de deux mots, on pourrait
faire ceci : 

```r
str_view(noms,"^\\w+ \\w+$")
```

```
 [2] â”‚ <owl monkey>
 [3] â”‚ <mountain beaver>
 [8] â”‚ <vesper mouse>
[10] â”‚ <roe deer>
[12] â”‚ <guinea pig>
[19] â”‚ <tree hyrax>
[21] â”‚ <asian elephant>
[25] â”‚ <european hedgehog>
[26] â”‚ <patas monkey>
[28] â”‚ <domestic cat>
[31] â”‚ <pilot whale>
[32] â”‚ <gray seal>
[33] â”‚ <gray hyrax>
[35] â”‚ <mongoose lemur>
[36] â”‚ <african elephant>
[39] â”‚ <mongolian gerbil>
[40] â”‚ <golden hamster>
[42] â”‚ <house mouse>
[45] â”‚ <slow loris>
[55] â”‚ <desert hedgehog>
... and 14 more
```

Il existe aussi sÃ©rie d'autres caractÃ¨res semblables, dont voici un aperÃ§u : 

* `\d` : n'importe quel chiffre
* `\D` : tout sauf un chiffre
* `\s` : n'importe quel caractÃ¨re d'espacement (espace, saut de ligne, indentation)
* `\S` : tout sauf un espacement
* `\w` : n'importe quelle lettre ou chiffre
* `\W` : tout ce qui n'est pas une lettre ou un chiffre

Au delÃ  des caractÃ¨res `+`, `?` et `*`, les regex nous permettent aussi un contrÃ´le
plus fin du nombre de rÃ©pÃ©tition d'un patron, Ã  l'aide des accolades. Pour trouver tous les noms commenÃ§ant par un mots de 3 lettres suivi d'un espace, on pourrait faire ceci :

```r
str_view(noms,"^\\w{3}\\s")
```

```
 [2] â”‚ <owl >monkey
[10] â”‚ <roe >deer
[22] â”‚ <big >brown bat
[83] â”‚ <red >fox
```

Remarquez qu'il existe aussi un caractÃ¨re spÃ©cial permettant de dÃ©tecter les
frontiÃ¨res entourant un mot : `\b`.

Si on veut trouver tous les noms comprenant un mot d'exactement 3 lettres, on pourrait faire ceci : 

```r
str_view(noms, "\\b\\w{3}\\b")
```

```
 [2] â”‚ <owl> monkey
 [5] â”‚ <cow>
 [7] â”‚ northern <fur> seal
 [9] â”‚ <dog>
[10] â”‚ <roe> deer
[12] â”‚ guinea <pig>
[16] â”‚ african giant pouched <rat>
[22] â”‚ <big> brown <bat>
[28] â”‚ domestic <cat>
[43] â”‚ little brown <bat>
[64] â”‚ laboratory <rat>
[68] â”‚ cotton <rat>
[69] â”‚ mole <rat>
[74] â”‚ <pig>
[82] â”‚ arctic <fox>
[83] â”‚ <red> <fox>
```

Si on ne mentionne qu'un chiffre, les accolades cherchent un nombre exact de 
dÃ©tections, mais on peut aussi spÃ©cifier deux valeurs, qui donneront les bornes
du nombre de dÃ©tection acceptable.

Par exemple, pour trouver tous les noms d'animaux comprenant un mot de 3 Ã  5 lettres,
on Ã©crirait ceci : 

```r
str_view(noms, "\\b\\w{3,5}\\b")
```

```
 [2] â”‚ <owl> monkey
 [4] â”‚ greater <short>-tailed <shrew>
 [5] â”‚ <cow>
 [6] â”‚ <three>-<toed> <sloth>
 [7] â”‚ northern <fur> <seal>
 [8] â”‚ vesper <mouse>
 [9] â”‚ <dog>
[10] â”‚ <roe> <deer>
[11] â”‚ <goat>
[12] â”‚ guinea <pig>
[15] â”‚ <star>-<nosed> <mole>
[16] â”‚ african <giant> pouched <rat>
[17] â”‚ lesser <short>-tailed <shrew>
[18] â”‚ <long>-<nosed> armadillo
[19] â”‚ <tree> <hyrax>
[20] â”‚ <north> american opossum
[21] â”‚ <asian> elephant
[22] â”‚ <big> <brown> <bat>
[23] â”‚ <horse>
[26] â”‚ <patas> monkey
... and 37 more
```

## PrioritÃ© d'opÃ©ration

Tout comme en mathÃ©matiques, l'Ã©valuation d'un regex ne s'effectue pas nÃ©cessairement de gauche Ã  droite. Il existe un ordre de prioritÃ© entre les opÃ©rations.

En rÃ¨gle gÃ©nÃ©rale, les caractÃ¨res contrÃ´lant le nombre de rÃ©pÃ©titions ont prÃ©sÃ©ance
sur ceux dÃ©finissant des alternatives.

Par exemple `ab+` sera interprÃ©tÃ© comme `a(b+)`. `^a|b$` sera interprÃ©tÃ© comme `(^a)|(b$)`, etc.

Contrairement Ã  l'algÃ¨bre, ces prioritÃ©s sont trÃ¨s difficiles Ã  retenir, et le plus
simple est probablement d'utiliser autant de parenthÃ¨ses que nÃ©cessaire pour
clarifier le patron recherchÃ©.

## Regroupements et rÃ©utilisation
Outre la clarification des prioritÃ©s, les parenthÃ¨ses ont une autre utilisation
particuliÃ¨re dans les regex : elles crÃ©ent des groupes qui peuvent Ãªtre rÃ©utilisÃ©s. Chacun des groupes dÃ©finis par les parenthÃ¨ses est numÃ©rotÃ© automatiquement par R. Ces numÃ©ros
peuvent ensuite Ãªtre utilisÃ©s ailleurs dans le regex. Le premier groupe
sera nommÃ© `\1`, le deuxiÃ¨me `\2`, etc.

On peut par exemple trouver tous les animaux dont le nom comporte une double lettre, comme ceci : 

```r
str_view(noms,"(\\w)\\1")
```

```
 [1] â”‚ ch<ee>tah
 [6] â”‚ thr<ee>-toed sloth
[10] â”‚ roe d<ee>r
[14] â”‚ chinchi<ll>a
[17] â”‚ le<ss>er short-tailed shrew
[18] â”‚ long-nosed armadi<ll>o
[19] â”‚ tr<ee> hyrax
[20] â”‚ north american opo<ss>um
[30] â”‚ gira<ff>e
[35] â”‚ mong<oo>se lemur
[37] â”‚ thick-tailed o<pp>osum
[43] â”‚ li<tt>le brown bat
[47] â”‚ northern gra<ss>ho<pp>er mouse
[48] â”‚ ra<bb>it
[49] â”‚ sh<ee>p
[50] â”‚ chimpanz<ee>
[54] â”‚ bab<oo>n
[56] â”‚ po<tt>o
[57] â”‚ d<ee>r mouse
[60] â”‚ co<mm>on porpoise
... and 9 more
```
Le `\w` attrape une lettre, les parenthÃ¨ses crÃ©ent un groupe (ici le numÃ©ro 1),
et ensuite un rÃ©utilise ce groupe pour crÃ©er le doublon.

Par le mÃªme principe, on peut aussi trouver tous les noms qui commencent et 
finissent par la mÃªme lettre : 

```r
str_view(noms,"^(\\w).*\\1$")
```

```
[10] â”‚ <roe deer>
[12] â”‚ <guinea pig>
[45] â”‚ <slow loris>
[67] â”‚ <eastern american mole>
```

La rÃ©utilisation de patrons est aussi applicable avec la fonction `str_replace`.

Elle peut permettre par exemple d'inverser les deux premiers mots de chaque nom : 

```r
str_replace(noms,"^(\\w+)\\s(\\w+)(.*)", "\\2 \\1\\3")
```

```
 [1] "cheetah"                        "monkey owl"                    
 [3] "beaver mountain"                "short greater-tailed shrew"    
 [5] "cow"                            "three-toed sloth"              
 [7] "fur northern seal"              "mouse vesper"                  
 [9] "dog"                            "deer roe"                      
[11] "goat"                           "pig guinea"                    
[13] "grivet"                         "chinchilla"                    
[15] "star-nosed mole"                "giant african pouched rat"     
[17] "short lesser-tailed shrew"      "long-nosed armadillo"          
[19] "hyrax tree"                     "american north opossum"        
[21] "elephant asian"                 "brown big bat"                 
[23] "horse"                          "donkey"                        
[25] "hedgehog european"              "monkey patas"                  
[27] "american western chipmunk"      "cat domestic"                  
[29] "galago"                         "giraffe"                       
[31] "whale pilot"                    "seal gray"                     
[33] "hyrax gray"                     "human"                         
[35] "lemur mongoose"                 "elephant african"              
[37] "thick-tailed opposum"           "macaque"                       
[39] "gerbil mongolian"               "hamster golden"                
[41] "vole "                          "mouse house"                   
[43] "brown little bat"               "round-tailed muskrat"          
[45] "loris slow"                     "degu"                          
[47] "grasshopper northern mouse"     "rabbit"                        
[49] "sheep"                          "chimpanzee"                    
[51] "tiger"                          "jaguar"                        
[53] "lion"                           "baboon"                        
[55] "hedgehog desert"                "potto"                         
[57] "mouse deer"                     "phalanger"                     
[59] "seal caspian"                   "porpoise common"               
[61] "potoroo"                        "armadillo giant"               
[63] "hyrax rock"                     "rat laboratory"                
[65] "striped african mouse"          "monkey squirrel"               
[67] "american eastern mole"          "rat cotton"                    
[69] "rat mole"                       "ground arctic squirrel"        
[71] "thirteen-lined ground squirrel" "golden-mantled ground squirrel"
[73] "shrew musk"                     "pig"                           
[75] "short-nosed echidna"            "american eastern chipmunk"     
[77] "tapir brazilian"                "tenrec"                        
[79] "shrew tree"                     "bottle-nosed dolphin"          
[81] "genet"                          "fox arctic"                    
[83] "fox red"                       
```
Nous avons ici 3 duos de parenthÃ¨ses, donc 3 groupes. Le premier attrape le
premier mot (`\w+`), le deuxiÃ¨me le second mot (encore `\w+`) et le dernier
attrape tout le reste (`.*`). Ensuite, on reconstruit une chaÃ®ne de caractÃ¨res,
mais en plaÃ§ant le deuxiÃ¨me groupe (`\2`) avant le premier (`\1`).

# Mise en garde
Comme dit si bien Spider-man : Ã€ grand pouvoir correspond grande responsabilitÃ©.

C'est particuliÃ¨rement vrai lorsque l'on parle de regex. Vaut mieux y aller avec modÃ©ration. Il peut parfois Ãªtre plus lisible pour votre "vous" futur de sÃ©parer
ce que vous avez Ã  faire en quelques opÃ©rations simples et lisibles, plutÃ´t que
d'essayer de tout faire dans un regex.

Je vous prÃ©sente en conclusion un regex classique, utilisÃ© dans une librairie
du langage de programmation Perl pour valider si une adresse de courriel est 
valide ou non (https://metacpan.org/release/RJBS/Email-Valid-1.200/source/lib/Email/Valid.pm) : 

```perl
[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\
xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xf
f\n\015()]*)*\)[\040\t]*)*(?:(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\x
ff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n\015
"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\
xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80
-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*
)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\
\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\
x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x8
0-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|"[^\\\x80-\xff\n
\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[\040\t]*(?:\([^\\\x
80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^
\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040
\t]*)*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([
^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\
\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\
x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-
\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()
]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\
x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\04
0\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\
n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\
015()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?!
[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\
]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\
x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\01
5()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*|(?:[^(\040)<>@,;:".
\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]
)|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^
()<>@,;:".\\\[\]\x80-\xff\000-\010\012-\037]*(?:(?:\([^\\\x80-\xff\n\0
15()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][
^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)|"[^\\\x80-\xff\
n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015"]*)*")[^()<>@,;:".\\\[\]\
x80-\xff\000-\010\012-\037]*)*<[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?
:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-
\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:@[\040\t]*
(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015
()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()
]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\0
40)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\
[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\
xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*
)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80
-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x
80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t
]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\
\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])
*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x
80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80
-\xff\n\015()]*)*\)[\040\t]*)*)*(?:,[\040\t]*(?:\([^\\\x80-\xff\n\015(
)]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\
\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*@[\040\t
]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\0
15()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015
()]*)*\)[\040\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(
\040)<>@,;:".\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|
\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80
-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()
]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x
80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^
\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040
\t]*)*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".
\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff
])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\
\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x
80-\xff\n\015()]*)*\)[\040\t]*)*)*)*:[\040\t]*(?:\([^\\\x80-\xff\n\015
()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\
\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)?(?:[^
(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-
\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\xff\
n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|
\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))
[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff
\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\x
ff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(
?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\
000-\037\x80-\xff])|"[^\\\x80-\xff\n\015"]*(?:\\[^\x80-\xff][^\\\x80-\
xff\n\015"]*)*")[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\x
ff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)
*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*@[\040\t]*(?:\([^\\\x80-\x
ff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-
\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)
*(?:[^(\040)<>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\
]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]
)[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-
\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\x
ff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(
?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80
-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)<
>@,;:".\\\[\]\000-\037\x80-\xff]+(?![^(\040)<>@,;:".\\\[\]\000-\037\x8
0-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:
\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]
*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)
*\)[\040\t]*)*)*>)
```
# RÃ©fÃ©rences

La plupart du matÃ©riel de cet atelier est fortement inspirÃ© des chapitres en construction de la prochaine Ã©dition de R for Data Science de Hadley Wickham, disponibles en ligne ici :

<https://r4ds.hadley.nz/strings.html>

<https://r4ds.hadley.nz/regexps.html>
